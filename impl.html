<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NEML2: Implementation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams','[tex]/physics']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams','physics']
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">NEML2<span id="projectnumber">&#160;1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('impl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Implementation</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#primitive">NEML2 tensor types</a></li>
<li class="level1"><a href="#labeledview">Tensor view and label</a></li>
<li class="level1"><a href="#modeldefinition">Model definition</a></li>
<li class="level1"><a href="#modelcomposition">Model composition</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="primitive"></a>
NEML2 tensor types</h1>
<p>Currently, libTorch is the only supported tensor backend in NEML2. Therefore, all tensor types in NEML2 directly inherit from <code>torch::Tensor</code>. In the future, support for other tensor backend libraries may be added, but the public-facing interfaces will remain largely the same.</p>
<h2>BatchTensor</h2>
<p><a class="el" href="classneml2_1_1BatchTensor.html">BatchTensor</a> is a general purpose tensor type for batched <code>torch::Tensor</code>s. With a view towards vectorization, the same set of operations can be "simultaneously" applied to a large "batch" of (logically the same) tensors. To provide a unified user interface for dealing with such batched operation, NEML2 assumes that the <em>first</em> \(N\) dimensions of a tensor are batched dimensions, and the following dimensions are the base (logical) dimensions.</p>
<blockquote class="doxtable">
<p>&zwj;Unlike libTorch, NEML2 explicitly distinguishes between batch dimensions and base (logical) dimensions. </p>
</blockquote>
<p>The <code>BatchTensor</code> is templated on the number of batch dimensions \(N\). Although the number of batched dimensions is known at compile time, the size of each dimension is not. The batch dimensions can be reshaped at runtime. For example, a <code>BatchTensor</code> can be created as </p><div class="fragment"><div class="line">BatchTensor&lt;2&gt; A = torch::rand({1, 1, 5, 2});</div>
</div><!-- fragment --><p> where <code>A</code> is a tensor with 2 batch dimensions. The batch sizes of <code>A</code> is <code>(1, 1)</code>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> batch_sz = A.batch_sizes();</div>
<div class="line"><span class="comment">// batch_sz == {1, 1}</span></div>
</div><!-- fragment --><p> and the base (logical) sizes of <code>A</code> is <code>(5, 2)</code>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> base_sz = A.base_sizes();</div>
<div class="line"><span class="comment">// batch_sze == {5, 2}</span></div>
</div><!-- fragment --><p> The base tensor can be reshaped (e.g., expanded and copied) at runtime along its batch dimensions using </p><div class="fragment"><div class="line">BatchTensor&lt;2&gt; B = A.batch_expand_copy({3, 4});</div>
<div class="line"><span class="keyword">auto</span> new_batch_sz = B.batch_sizes();</div>
<div class="line"><span class="comment">// new_batch_sz == {3, 4}</span></div>
</div><!-- fragment --><h2>FixedDimTensor</h2>
<p><a class="el" href="classneml2_1_1FixedDimTensor.html">FixedDimTensor</a> inherits from <code>BatchTensor</code>. It is additionally templated on the sizes of the base dimensions. For example, </p><div class="fragment"><div class="line"><span class="keyword">static_assert</span>(FixedDimTensor&lt;2, 6&gt;::const_base_sizes == {6});</div>
</div><!-- fragment --><h2>Primitive tensor types</h2>
<p>All primitive tensor types inherit from <code>FixedDimTensor</code> with a <em>single</em> batch dimension. Currently implemented primitive tensor types include</p><ul>
<li><a class="el" href="classneml2_1_1Scalar.html">Scalar</a>, a (batched) scalar quantity derived from the specialization <code>FixedDimTensor&lt;1, 1&gt;</code></li>
<li>SymR2, a (batched) symmetric second order tensor derived from the specialization <code>FixedDimTensor&lt;1, 6&gt;</code></li>
<li>SymSymR4, a (batched) symmetric fourth order tensor derived from the specialization <code>FixedDimTensor&lt;1, 6, 6&gt;</code></li>
</ul>
<p>Furthermore, all primitive tensor types can be "registered" as variables on a <code>LabeledAxis</code>, which will be discussed in the following section on <a class="el" href="impl.html#labeledview">labeled view</a>.</p>
<h1><a class="anchor" id="labeledview"></a>
Tensor view and label</h1>
<h2>Tensor view</h2>
<p>In defining the forward operator of a constitutive model, many logically different tensors representing inputs, outputs, residuals, and Jacobians have to be created, copied, and destroyed on the fly. These operations occupy a significant amount of computing time, especially on GPUs.</p>
<p>To address this challenge, NEML2 creates <em>views</em>, instead of copies, of tensors whenever possible. As its name suggests, the view of a tensor is a possibly different interpretation of the underlying data. Quoting the PyTorch documentation:</p>
<blockquote class="doxtable">
<p>&zwj;For a tensor to be viewed, the new view size must be compatible with its original size and stride, i.e., each new view dimension must either be a subspace of an original dimension, or only span across original dimensions \(d, d+1, ..., d+k\) that satisfy the following contiguity-like condition that \(\forall i = d,...,d+k-1\),  </p><p class="formulaDsp">
\[
\text{stride}[i] = \text{stride}[i+1] \times \text{size}[i+1]
\]
</p>
<p> Otherwise, it will not be possible to view self tensor as shape without copying it. </p>
</blockquote>
<h2>Working with tensor views</h2>
<p>In NEML2, to index a view of a <code>BatchTensor</code>, use <a class="el" href="classneml2_1_1BatchTensorBase.html#a7d5d18a59ce434544c87d26d81e702f8">base_index</a> for indexing the base dimensions and <a class="el" href="classneml2_1_1BatchTensorBase.html#a7133d83ffd76e1e139b2e8d439261552">batch_index</a> for indexing the batch dimensions: </p><div class="fragment"><div class="line">BatchTensor&lt;1, 3&gt; A = torch::tensor({{2, 3, 4}, {-1, -2, 3}, {6, 9, 7}});</div>
<div class="line"><span class="comment">// A = [[  2  3  4]</span></div>
<div class="line"><span class="comment">//      [ -1 -2  3]</span></div>
<div class="line"><span class="comment">//      [  6  9  7]]</span></div>
<div class="line"><span class="keyword">using namespace </span>torch::indexing;</div>
<div class="line">BatchTensor&lt;1, 3&gt; B = A.batch_index({Slice(0, 2)});</div>
<div class="line"><span class="comment">// B = [[  2  3  4]</span></div>
<div class="line"><span class="comment">//      [ -1 -2  3]]</span></div>
<div class="line">BatchTensor&lt;1, 3&gt; C = A.base_index({Slice(1, 3)});</div>
<div class="line"><span class="comment">// C = [[  3  4]</span></div>
<div class="line"><span class="comment">//      [ -2  3]</span></div>
<div class="line"><span class="comment">//      [  9  7]]</span></div>
</div><!-- fragment --><p> To modify a view of a <code>BatchTensor</code>, use <a class="el" href="classneml2_1_1BatchTensorBase.html#a9de98367492b84450c58a223e3473d4a">base_index_put</a> or <a class="el" href="classneml2_1_1BatchTensorBase.html#ada0be5f6e51644bf2c0740226b925002">batch_index_put</a>: </p><div class="fragment"><div class="line">A.base_index_put({Slice(1, 3)}, torch::ones({3, 2}));</div>
<div class="line"><span class="comment">// A = [[  2  1  1]</span></div>
<div class="line"><span class="comment">//      [ -1  1  1]</span></div>
<div class="line"><span class="comment">//      [  6  1  1]]</span></div>
<div class="line">A.batch_index_put({Slice(0, 2)}, torch::zeros({2, 3}));</div>
<div class="line"><span class="comment">// A = [[  0  0  0]</span></div>
<div class="line"><span class="comment">//      [  0  0  0]</span></div>
<div class="line"><span class="comment">//      [  6  1  1]]</span></div>
</div><!-- fragment --><p> A detailed explanation on tensor indexing APIs is available as part of the official <a href="https://pytorch.org/cppdocs/notes/tensor_indexing.html">PyTorch documentation</a>.</p>
<h2>Labeled tensor view</h2>
<p>In the context of constitutive modeling, often times views of tensors have practical/physical meanings. For example, given a logically 1D tensor with base size 9, its underlying data in an arbitrary batch may look like </p><div class="fragment"><div class="line">equivalent plastic strain   2.1</div>
<div class="line">            cauchy stress  -2.1</div>
<div class="line">                              0</div>
<div class="line">                            1.3</div>
<div class="line">                           -1.1</div>
<div class="line">                            2.5</div>
<div class="line">                            2.5</div>
<div class="line">              temperature 102.9</div>
<div class="line">                     time   3.6</div>
</div><!-- fragment --><p> where component 0 stores the scalar-valued equivalent plastic strain, components 1-6 store the tensor-valued cauchy stress (recall that we use the <a class="el" href="math.html#mandel">Mandel</a> notation for symmetric second order tensors), component 7 stores the scalar-valued temperature, and component 8 stores the scalar-valued time.</p>
<p>The string indicating the physical meaning of the view, e.g., "cauchy stress", is called a "label", and the view of the tensor indexed by a label is called a "labeled view", i.e., </p><div class="fragment"><div class="line">cauchy stress  -2.1</div>
<div class="line">                  0</div>
<div class="line">                1.3</div>
<div class="line">               -1.1</div>
<div class="line">                2.5</div>
<div class="line">                2.5</div>
</div><!-- fragment --><p>NEML2 provides a data structure named <a class="el" href="classneml2_1_1LabeledAxis.html">LabeledAxis</a> to facilitate the creation and modification of labels, and a data structure named <a class="el" href="classneml2_1_1LabeledTensor.html">LabeledTensor</a> to facilitate the creation and modification of labeled views.</p>
<h2>LabeledAxis</h2>
<p>The <a class="el" href="classneml2_1_1LabeledAxis.html">LabeledAxis</a> contains all information regarding how an axis of a <code>LabeledTensor</code> is labeled. The following naming convention is used:</p><ul>
<li>Item: A labelable chunk of data</li>
<li>Variable: An item that is also of a <a class="el" href="impl.html#primitive">NEML2 primitive tensor type</a></li>
<li>Sub-axis: An item of type <code>LabeledAxis</code></li>
</ul>
<p>So yes, an axis can be labeled recursively, e.g.,</p>
<div class="fragment"><div class="line">     0 1 2 3 4 5     6     7 8 9 10 11 12   13   14</div>
<div class="line">/// |-----------| |-----| |              | |  | |  |</div>
<div class="line">///       a          b    |              | |  | |  |</div>
<div class="line">/// |-------------------| |--------------| |--| |--|</div>
<div class="line">///          sub                  a          b    c</div>
</div><!-- fragment --><p> The above example represents an axis of size 15. This axis has 4 items: <code>a</code>, <code>b</code>, <code>c</code>, and <code>sub</code>.</p><ul>
<li>"a" is a variable of storage size 6 (possibly of type <code>SymR2</code>).</li>
<li>"b" is a variable of type <code>Scalar</code>.</li>
<li>"c" is a variable of type <code>Scalar</code>.</li>
<li>"sub" is a sub-axis of type <code>LabeledAxis</code>. "sub" by itself represents an axis of size 7, containing 2 items:<ul>
<li>"a" is a variable of storage size 6.</li>
<li>"b" is a variable of type <code>Scalar</code>.</li>
</ul>
</li>
</ul>
<p>Duplicate labels are <em>not</em> allowed on the same level of the axis, e.g. "a", "b", "c", and "sub" share the same level and so must be different. However, items on different levels of an axis can share the same label, e.g., "a" on the sub-axis "sub" has the same label as "a" on the main axis. In NEML2 convention, item names are always fully qualified, and a sub-axis is prefixed with a left slash, e.g. item "b" on the sub-axis "sub" can be denoted as "sub/b" on the main axis.</p>
<blockquote class="doxtable">
<p>&zwj;A label cannot contain: white spaces, quotes, left slash (<code>/</code>), or new line. </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;Due to performance considerations, a <code>LabeledAxis</code> can only be modified, e.g., adding/removing variables and sub-axis, at the time a model is constructed. After the model construction phase, the <code>LabeledAxis</code> associated with that model can no longer be modified over the entire course of the simulation. </p>
</blockquote>
<p>Refer to the doxygen documentation for a complete list of APIs for creating and modifying a <a class="el" href="classneml2_1_1LabeledAxis.html">LabeledAxis</a>.</p>
<h2>LabeledTensor</h2>
<p><a class="el" href="classneml2_1_1LabeledTensor.html">LabeledTensor</a> is the primary data structure in NEML2 for working with labeled tensor views. Each <code>LabeledTensor</code> consists of one <code>BatchTensor</code> and one or more <code>LabeledAxis</code>s. The <code>LabeledTensor&lt;N, D&gt;</code> is templated on the batch dimension \(N\) and the base dimension \(D\). <a class="el" href="classneml2_1_1LabeledVector.html">LabeledVector</a> (derived from <code>LabeledTensor&lt;1, 1&gt;</code>) and <a class="el" href="classneml2_1_1LabeledMatrix.html">LabeledMatrix</a> (derived from <code>LabeledTensor&lt;1, 2&gt;</code>) are the two most widely used data structures in NEML2.</p>
<p><code>LabeledTensor</code> handles the creation, modification, and accessing of labeled tensors. Recall that all primitive data types in a labeled tensor are flattened, e.g., a symmetric fourth order tensor of type <code>SymSymR4</code> with batch size <code>(5)</code> and base size <code>(6, 6)</code> are flattened to have base size <code>(36)</code> in the labeled tensor. The doxygen documentation provides a complete list of APIs. The commonly used methods are</p><ul>
<li><a class="el" href="classneml2_1_1LabeledTensor.html#a2e2fb92a0c6d84ad7d6cbb2c00de011e">operator()</a> for retrieving a labeled view into the raw (flattened) data without reshaping</li>
<li><a class="el" href="classneml2_1_1LabeledTensor.html#afec36430e0f802eeccaf877e68d6f553">get</a> for retrieving a labeled view and reshaping it to the correct shape</li>
<li><a class="el" href="classneml2_1_1LabeledTensor.html#aaadfa72fc5b16ef9a08aebcca86411d9">set</a> for setting values for a labeled view</li>
<li><a class="el" href="classneml2_1_1LabeledTensor.html#a25c6a6bc3b0d8973ccbf8bca512d33e0">slice</a> for slicing a sub-axis along a specific base dimension</li>
<li><a class="el" href="classneml2_1_1LabeledTensor.html#a73978d4287506808ddd5adea60eda28f">block</a> for sub-indexing the <code>LabeledTensor</code> with \(D\) sub-axis names</li>
</ul>
<h1><a class="anchor" id="modeldefinition"></a>
Model definition</h1>
<p>A NEML2 model is a function (in the context of mathematics)  </p><p class="formulaDsp">
\[
  f: \mathbb{R}^m \to \mathbb{R}^n
\]
</p>
<p> mapping from the input space \(\mathbb{R}^m\) of dimension \(m\) to the output space \(\mathbb{R}^n\) of dimension \(n\). Recall that \(\left[ \cdot \right]\) is the <a class="el" href="math.html">flatten-concatenation operator</a>. The input vector is the concatenation of \(p\) flattened variables, i.e.,  </p><p class="formulaDsp">
\[
  x = \left[ x_i \right]_{i=1}^p \in \mathbb{R}^m, \quad \sum_{i=1}^p \lvert x_i \rvert = m,
\]
</p>
<p> where \(\lvert x \rvert\) denotes the modulus of flattened variable \(x\). Similarly, the output vector is the concatenation of \(q\) flattened variables, i.e.,  </p><p class="formulaDsp">
\[
  y = \left[ y_i \right]_{i=1}^q \in \mathbb{R}^n, \quad \sum_{i=1}^q \lvert y_i \rvert = n.
\]
</p>
<p>Translating the above mathematical definition into NEML2 is straightforward.</p><ul>
<li>A model following this definition derives from <a class="el" href="classneml2_1_1Model.html">Model</a>.</li>
<li><a class="el" href="classneml2_1_1VariableStore.html#a40ad626c6229a766a9562f76de8a75a2">declare_input_variable</a> declares an input variable \(x_i\) in the input space \(\mathbb{R}^m\).</li>
<li><a class="el" href="classneml2_1_1VariableStore.html#a32f2809f2a025ca49ef2b97e16c9a913">declare_output_variable</a> declares an output variable \(y_i\) in the output space \(\mathbb{R}^n\).</li>
<li><a class="el" href="classneml2_1_1Model.html#a6a028925dc10166ea6426fc4d7635ad2">set_value</a> is a method defining the forward operator \(f\).</li>
</ul>
<p>Both <code>declare_input_variable</code> and <code>declare_output_variable</code> are templated on the variable type &ndash; recall that only a variable of the NEML2 primitive tensor type can be registered. Furthermore, both calls return a convenient accessor of type <a class="el" href="namespaceneml2.html#a9e1488821b46ffc106c90ab80036b7aa">VariableName</a> which can be later used to retrieve/modify the labeled view of the input/output vector.</p>
<blockquote class="doxtable">
<p>&zwj;Declaration of the variables don't immediately set up the layout of the input/output <code>LabeledAxis</code>. The method <a class="el" href="classneml2_1_1Model.html#ac0b73dc40ca33ff933c1f351578a00d0">setup</a> should be explicitly called in order to set up the memory layout of the <code>LabeledAxis</code>s. <b>Note that <a class="el" href="classneml2_1_1Model.html#ac0b73dc40ca33ff933c1f351578a00d0">setup</a> must be called after all the variables have been added, and before the forward operator of the <code>Model</code> can be used.</b> </p>
</blockquote>
<h1><a class="anchor" id="modelcomposition"></a>
Model composition</h1>
<p>Quoting <a href="https://en.wikipedia.org/wiki/Function_composition">Wikipedia</a>: </p><blockquote class="doxtable">
<p>&zwj;In mathematics, function composition is an operation \(\circ\) that takes two functions \(f\) and \(g\), and produces a function \(h = g \circ f\) such that \(h(x) = g(f(x))\). </p>
</blockquote>
<p>Since NEML2 <code>Model</code> is a function (in the context of mathematics) at its core, it should be possible, in theory, to compose different NEML2 <code>Model</code>s into a new NEML2 <code>Model</code>. The <a class="el" href="classneml2_1_1ComposedModel.html">ComposedModel</a> is precisely for that purpose.</p>
<p>Similar to the statement "a composed function is a function" in the context of mathematics, in NEML2, the equivalent statement "a ComposedModel is a Model" also holds. In addition, the <code>ComposedModel</code> provides four key features to help simplify the composition and reduces computational cost:</p><ul>
<li>Automatic dependency registration</li>
<li>Automatic input/output identification</li>
<li>Automatic dependency resolution</li>
<li>Automatic chain rule</li>
</ul>
<h2>A symbolic example</h2>
<p>To demonstrate the utility of the four key features of <code>ComposedModel</code>, let us consider the composition of three functions \(f\), \(g\), and \(h\):  </p><p class="formulaDsp">
\begin{align*}
  y_1 &amp;= f(x_1, x_2), \\
  y_2 &amp;= g(y_1, x_3), \\
  y &amp;= h(y_1, y_2, x_4).
\end{align*}
</p>
<h2>Automatic dependency registration</h2>
<p>It is obvious to us that the function \(h\) <em>depends</em> on functions \(f\) and \(g\) because the input of \(h\) depends on the outputs of \(f\) and \(g\). Such dependency is automatically identified and registered while composing a <code>ComposedModel</code> in NEML2. This procedure is called "automatic dependency registration".</p>
<p>In order to identify dependencies among different <code>Model</code>s, we keep track of the set of <em>consumed</em> variables, \(\mathcal{I}_i\), and a set of <em>provided</em> variables, \(\mathcal{O}_i\), for each <code>Model</code> \(f_i\). When a set of models (functions) are composed together, <code>Model</code> \(f_i\) is said to <em>depend</em> on \(f_j\) if and only if \(\exists x\) such that  </p><p class="formulaDsp">
\[
  x \in \mathcal{I}_i \wedge x \in \mathcal{O}_j.
\]
</p>
<h2>Automatic input/output identification</h2>
<p>The only possible composition \(r\) of these three functions is  </p><p class="formulaDsp">
\[
  y = r(x_1, x_2, x_3, x_4) := h(f(x_1, x_2), g(f(x_1, x_2), x_3), x_4).
\]
</p>
<p> The input variables of the composed function \(r\) are \([x_1, x_2, x_3, x_4]\) (or their flattened concatenation), and the output variable of the composed function is simply \(y\). The input/output variables are automatically identified while composing a <code>ComposedModel</code> in NEML2. This procedure is referred to as "automatic input/output identification".</p>
<p>In a <code>ComposedModel</code>, a <em>leaf</em> model is a model which does not depend on any other model, and a <em>root</em> model is a model which is not depent upon by any other model. A <code>ComposedModel</code> may have multiple leaf models and multiple root models. An input variable is said to be a <em>root</em> input variable if it is not consumed by any other model, i.e. \(x \in \mathcal{I}_i\) is a root input variable if and only if  </p><p class="formulaDsp">
\[
    x \notin \mathcal{O}_j, \quad \forall i \neq j.
\]
</p>
<p> Similarly, an output variable is said to be a <em>leaf</em> output variable if it is not provided by any other model, i.e. \(x \in \mathcal{O}_i\) is a leaf output variable if an only if  </p><p class="formulaDsp">
\[
    x \notin \mathcal{I}_j, \quad \forall i \neq j.
\]
</p>
<p> The input variables of a <code>ComposedModel</code> is the union of the set of all the root input variables, and the output variables of a <code>ComposedModel</code> is the set of all the leaf output variables.</p>
<h2>Automatic dependency resolution</h2>
<p>To evaluate the forward operator of the composed model \(r\), one has to first evaluate model \(f\), then model \(g\), and finally model \(h\). The process of sorting out such evaluation order is called "dependency resolution".</p>
<p>While it is possible to sort the evaluation order "by hand" for this simple example composition, it is generally not a trivial task for practical compositions with more involved dependencies. To that end, NEML2 uses <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sort</a> to sort the model evaluation order, such that by the time each model is evaluated, all of its dependent models have already been evaluated.</p>
<h2>Automatic chain rule</h2>
<p>Chain rule can be applied to evaluate the derivative of the forward operator with respect to the input variables, i.e.,  </p><p class="formulaDsp">
\begin{align*}
  \frac{\partial y}{\partial x_1} &amp;= \left( \frac{\partial y}{\partial y_1} + \frac{\partial y}{\partial y_2} \frac{\partial y_2}{\partial y_1} \right) \frac{\partial y_1}{\partial x_1}, \\
  \frac{\partial y}{\partial x_2} &amp;= \left( \frac{\partial y}{\partial y_1} + \frac{\partial y}{\partial y_2} \frac{\partial y_2}{\partial y_1} \right) \frac{\partial y_1}{\partial x_2}, \\
  \frac{\partial y}{\partial x_3} &amp;= \frac{\partial y}{\partial y_2} \frac{\partial y_2}{\partial x_3}, \\
  \frac{\partial y}{\partial x_4} &amp;= \frac{\partial y}{\partial x_4}.
\end{align*}
</p>
<p> Spelling out this chain rule can be cumbersome and error-prone, especially for more complicated model compositions. The evaluation of the chain rule is automated in NEML2, and the user is only responsible for implementing the partial derivatives of each model. For example, in the implementation of <code>Model</code> \(f\), the user only need to define the partial derivatives  </p><p class="formulaDsp">
\[
  \frac{\partial y_1}{\partial x_1}, \quad \frac{\partial y_1}{\partial x_2};
\]
</p>
<p> similarly, <code>Model</code> \(g\) only defines  </p><p class="formulaDsp">
\[
  \frac{\partial y_2}{\partial y_1}, \quad \frac{\partial y_2}{\partial x_3}
\]
</p>
<p> and <code>Model</code> \(h\) only defines  </p><p class="formulaDsp">
\[
  \frac{\partial y}{\partial y_1}, \quad \frac{\partial y}{\partial y_2}, \quad \frac{\partial y}{\partial x_4}.
\]
</p>
<p> The assembly of the partial derivatives into the total derivative \(\partial y / \partial \mathbf{x}\) using the chain rule is handled by NEML2. This design serves as the fundation for a modular model implementation:</p><ul>
<li>Each model <em>does not</em> need to know its composition with others.</li>
<li>The same model partial derivatives can be reused in <em>any</em> composition. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
