<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NEML2: [Models]</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams','[tex]/physics','[tex]/boldsymbol']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams','physics','boldsymbol']
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">NEML2<span id="projectnumber">&#160;1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('syntax-models.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">[Models]</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md45">Available objects and their input file syntax</a><ul><li class="level2"><a href="#arrheniusparameter">ArrheniusParameter</a></li>
<li class="level2"><a href="#associativeisotropicplastichardening">AssociativeIsotropicPlasticHardening</a></li>
<li class="level2"><a href="#associativekinematicplastichardening">AssociativeKinematicPlasticHardening</a></li>
<li class="level2"><a href="#associativeplasticflow">AssociativePlasticFlow</a></li>
<li class="level2"><a href="#chabocheplastichardening">ChabochePlasticHardening</a></li>
<li class="level2"><a href="#composedmodel">ComposedModel</a></li>
<li class="level2"><a href="#copymillerindex">CopyMillerIndex</a></li>
<li class="level2"><a href="#copyquaternion">CopyQuaternion</a></li>
<li class="level2"><a href="#copyr2">CopyR2</a></li>
<li class="level2"><a href="#copyr3">CopyR3</a></li>
<li class="level2"><a href="#copyr4">CopyR4</a></li>
<li class="level2"><a href="#copyr5">CopyR5</a></li>
<li class="level2"><a href="#copyrot">CopyRot</a></li>
<li class="level2"><a href="#copysffr4">CopySFFR4</a></li>
<li class="level2"><a href="#copysfr3">CopySFR3</a></li>
<li class="level2"><a href="#copysr2">CopySR2</a></li>
<li class="level2"><a href="#copyssfr5">CopySSFR5</a></li>
<li class="level2"><a href="#copyssr4">CopySSR4</a></li>
<li class="level2"><a href="#copyswr4">CopySWR4</a></li>
<li class="level2"><a href="#copyscalar">CopyScalar</a></li>
<li class="level2"><a href="#copyvec">CopyVec</a></li>
<li class="level2"><a href="#copywr2">CopyWR2</a></li>
<li class="level2"><a href="#copywsr4">CopyWSR4</a></li>
<li class="level2"><a href="#copywwr4">CopyWWR4</a></li>
<li class="level2"><a href="#elasticstrainrate">ElasticStrainRate</a></li>
<li class="level2"><a href="#fixorientation">FixOrientation</a></li>
<li class="level2"><a href="#fredrickarmstrongplastichardening">FredrickArmstrongPlasticHardening</a></li>
<li class="level2"><a href="#gtnyieldfunction">GTNYieldFunction</a></li>
<li class="level2"><a href="#gursoncavitation">GursonCavitation</a></li>
<li class="level2"><a href="#implicitupdate">ImplicitUpdate</a></li>
<li class="level2"><a href="#isotropicmandelstress">IsotropicMandelStress</a></li>
<li class="level2"><a href="#kocksmeckingactivationenergy">KocksMeckingActivationEnergy</a></li>
<li class="level2"><a href="#kocksmeckingflowswitch">KocksMeckingFlowSwitch</a></li>
<li class="level2"><a href="#kocksmeckingflowviscosity">KocksMeckingFlowViscosity</a></li>
<li class="level2"><a href="#kocksmeckingratesensitivity">KocksMeckingRateSensitivity</a></li>
<li class="level2"><a href="#kocksmeckingyieldstress">KocksMeckingYieldStress</a></li>
<li class="level2"><a href="#linearisotropicelasticity">LinearIsotropicElasticity</a></li>
<li class="level2"><a href="#linearisotropichardening">LinearIsotropicHardening</a></li>
<li class="level2"><a href="#linearkinematichardening">LinearKinematicHardening</a></li>
<li class="level2"><a href="#linearsinglesliphardeningrule">LinearSingleSlipHardeningRule</a></li>
<li class="level2"><a href="#millerindexconstantparameter">MillerIndexConstantParameter</a></li>
<li class="level2"><a href="#millerindexinputparameter">MillerIndexInputParameter</a></li>
<li class="level2"><a href="#mixedcontrolsetup">MixedControlSetup</a></li>
<li class="level2"><a href="#normality">Normality</a></li>
<li class="level2"><a href="#olevskysnumbereringstress">OlevskySnumbereringStress</a></li>
<li class="level2"><a href="#orientationrate">OrientationRate</a></li>
<li class="level2"><a href="#perzynaplasticflowrate">PerzynaPlasticFlowRate</a></li>
<li class="level2"><a href="#plasticdeformationrate">PlasticDeformationRate</a></li>
<li class="level2"><a href="#plasticvorticity">PlasticVorticity</a></li>
<li class="level2"><a href="#powerlawisotropichardeningstaticrecovery">PowerLawIsotropicHardeningStaticRecovery</a></li>
<li class="level2"><a href="#powerlawkinematichardeningstaticrecovery">PowerLawKinematicHardeningStaticRecovery</a></li>
<li class="level2"><a href="#powerlawsliprule">PowerLawSlipRule</a></li>
<li class="level2"><a href="#quaternionconstantparameter">QuaternionConstantParameter</a></li>
<li class="level2"><a href="#quaternioninputparameter">QuaternionInputParameter</a></li>
<li class="level2"><a href="#r2constantparameter">R2ConstantParameter</a></li>
<li class="level2"><a href="#r2inputparameter">R2InputParameter</a></li>
<li class="level2"><a href="#r3constantparameter">R3ConstantParameter</a></li>
<li class="level2"><a href="#r3inputparameter">R3InputParameter</a></li>
<li class="level2"><a href="#r4constantparameter">R4ConstantParameter</a></li>
<li class="level2"><a href="#r4inputparameter">R4InputParameter</a></li>
<li class="level2"><a href="#r5constantparameter">R5ConstantParameter</a></li>
<li class="level2"><a href="#r5inputparameter">R5InputParameter</a></li>
<li class="level2"><a href="#rateindependentplasticflowconstranumber">RateIndependentPlasticFlowConstranumber</a></li>
<li class="level2"><a href="#resolvedshear">ResolvedShear</a></li>
<li class="level2"><a href="#rotconstantparameter">RotConstantParameter</a></li>
<li class="level2"><a href="#rotinputparameter">RotInputParameter</a></li>
<li class="level2"><a href="#rotationmatrix">RotationMatrix</a></li>
<li class="level2"><a href="#sffr4constantparameter">SFFR4ConstantParameter</a></li>
<li class="level2"><a href="#sffr4inputparameter">SFFR4InputParameter</a></li>
<li class="level2"><a href="#sfr3constantparameter">SFR3ConstantParameter</a></li>
<li class="level2"><a href="#sfr3inputparameter">SFR3InputParameter</a></li>
<li class="level2"><a href="#sr2backwardeulertimeintegration">SR2BackwardEulerTimeIntegration</a></li>
<li class="level2"><a href="#sr2constantparameter">SR2ConstantParameter</a></li>
<li class="level2"><a href="#sr2forwardeulertimeintegration">SR2ForwardEulerTimeIntegration</a></li>
<li class="level2"><a href="#sr2inputparameter">SR2InputParameter</a></li>
<li class="level2"><a href="#sr2invariant">SR2Invariant</a></li>
<li class="level2"><a href="#sr2linearcombination">SR2LinearCombination</a></li>
<li class="level2"><a href="#sr2linearinterpolation">SR2LinearInterpolation</a></li>
<li class="level2"><a href="#sr2twostagethermalannealing">SR2TwoStageThermalAnnealing</a></li>
<li class="level2"><a href="#sr2variablerate">SR2VariableRate</a></li>
<li class="level2"><a href="#ssfr5constantparameter">SSFR5ConstantParameter</a></li>
<li class="level2"><a href="#ssfr5inputparameter">SSFR5InputParameter</a></li>
<li class="level2"><a href="#ssr4constantparameter">SSR4ConstantParameter</a></li>
<li class="level2"><a href="#ssr4inputparameter">SSR4InputParameter</a></li>
<li class="level2"><a href="#swr4constantparameter">SWR4ConstantParameter</a></li>
<li class="level2"><a href="#swr4inputparameter">SWR4InputParameter</a></li>
<li class="level2"><a href="#scalarbackwardeulertimeintegration">ScalarBackwardEulerTimeIntegration</a></li>
<li class="level2"><a href="#scalarconstantparameter">ScalarConstantParameter</a></li>
<li class="level2"><a href="#scalarforwardeulertimeintegration">ScalarForwardEulerTimeIntegration</a></li>
<li class="level2"><a href="#scalarinputparameter">ScalarInputParameter</a></li>
<li class="level2"><a href="#scalarlinearcombination">ScalarLinearCombination</a></li>
<li class="level2"><a href="#scalarlinearinterpolation">ScalarLinearInterpolation</a></li>
<li class="level2"><a href="#scalartwostagethermalannealing">ScalarTwoStageThermalAnnealing</a></li>
<li class="level2"><a href="#scalarvariablerate">ScalarVariableRate</a></li>
<li class="level2"><a href="#singleslipstrengthmap">SingleSlipStrengthMap</a></li>
<li class="level2"><a href="#slopesaturationvoceisotropichardening">SlopeSaturationVoceIsotropicHardening</a></li>
<li class="level2"><a href="#sumsliprates">SumSlipRates</a></li>
<li class="level2"><a href="#thermaleigenstrain">ThermalEigenstrain</a></li>
<li class="level2"><a href="#vecbackwardeulertimeintegration">VecBackwardEulerTimeIntegration</a></li>
<li class="level2"><a href="#vecconstantparameter">VecConstantParameter</a></li>
<li class="level2"><a href="#vecforwardeulertimeintegration">VecForwardEulerTimeIntegration</a></li>
<li class="level2"><a href="#vecinputparameter">VecInputParameter</a></li>
<li class="level2"><a href="#veclinearcombination">VecLinearCombination</a></li>
<li class="level2"><a href="#veclinearinterpolation">VecLinearInterpolation</a></li>
<li class="level2"><a href="#vecvariablerate">VecVariableRate</a></li>
<li class="level2"><a href="#voceisotropichardening">VoceIsotropicHardening</a></li>
<li class="level2"><a href="#vocesinglesliphardeningrule">VoceSingleSlipHardeningRule</a></li>
<li class="level2"><a href="#wr2constantparameter">WR2ConstantParameter</a></li>
<li class="level2"><a href="#wr2explicitexponentialtimeintegration">WR2ExplicitExponentialTimeIntegration</a></li>
<li class="level2"><a href="#wr2implicitexponentialtimeintegration">WR2ImplicitExponentialTimeIntegration</a></li>
<li class="level2"><a href="#wr2inputparameter">WR2InputParameter</a></li>
<li class="level2"><a href="#wsr4constantparameter">WSR4ConstantParameter</a></li>
<li class="level2"><a href="#wsr4inputparameter">WSR4InputParameter</a></li>
<li class="level2"><a href="#wwr4constantparameter">WWR4ConstantParameter</a></li>
<li class="level2"><a href="#wwr4inputparameter">WWR4InputParameter</a></li>
<li class="level2"><a href="#yieldfunction">YieldFunction</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_content_2syntax_2models"></a></p>
<dl class="section note"><dt>Note</dt><dd>Clicking on the option with a triangle bullet ▸ next to it will expand/collapse its detailed information.</dd>
<dd>
Type name written in PascalCase typically refer to a NEML2 object type, oftentimes a primitive tensor type.</dd>
<dd>
The 🔗 symbol denotes that the option can <a class="el" href="input-file.html#cross-referencing">cross-reference</a> another object.</dd>
<dd>
You can always use <code>Ctrl</code>+<code>F</code> or <code>Cmd</code>+<code>F</code> to search the entire page.</dd></dl>
<p>The following symbols are used throughout the documentation to denote different components of function definition.</p><ul>
<li>🇮: input variable</li>
<li>🇴: output variable</li>
<li>🇵: parameter</li>
<li>🇧: buffer</li>
</ul>
<h1><a class="anchor" id="autotoc_md45"></a>
Available objects and their input file syntax</h1>
<p>Refer to <a class="el" href="system-models.html">System Documentation</a> for detailed explanation about this system.</p>
<h2><a class="anchor" id="arrheniusparameter"></a>
ArrheniusParameter</h2>
<p>Define the nonlinear parameter as a function of temperature according to the Arrhenius law \( p = p_0 \exp \left( -\frac{Q}{RT} \right) \), where \( p_0 \) is the reference value, \( Q \) is the activation energy, \( R \) is the ideal gas constant, and \( T \) is the temperature. </p><details >
<summary >
<code>activation_energy</code> 🇵 Activation energy</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>ideal_gas_constant</code> The ideal gas constant</summary>
<p></p>
<ul>
<li><u>Type</u>: number </li>
</ul>
</details>
<details >
<summary >
<code>reference_value</code> 🇵 Reference value</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>temperature</code> 🇮 Temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/T </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ArrheniusParameter.html">link</a></p>
<h2><a class="anchor" id="associativeisotropicplastichardening"></a>
AssociativeIsotropicPlasticHardening</h2>
<p>Map the flow rate (i.e., the consistency parameter in the KKT conditions) to the rate of internal variables. This object calculates the rate of equivalent plastic strain following associative flow rule, i.e. \( \dot{\varepsilon}_p = - \dot{\gamma} \frac{\partial f}{\partial k} \), where \( \dot{\varepsilon}_p \) is the equivalent plastic strain, \( \dot{\gamma} \) is the flow rate, \( f \) is the yield function, and \( k \) is the isotropic hardening. </p><details >
<summary >
<code>equivalent_plastic_strain_rate</code> 🇴 Rate of equivalent plastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/ep_rate </li>
</ul>
</details>
<details >
<summary >
<code>flow_rate</code> 🇮 Flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>isotropic_hardening_direction</code> 🇮 Direction of associative isotropic hardening which can be calculated using Normality.</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/Nk </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1AssociativeIsotropicPlasticHardening.html">link</a></p>
<h2><a class="anchor" id="associativekinematicplastichardening"></a>
AssociativeKinematicPlasticHardening</h2>
<p>Map the flow rate (i.e., the consistency parameter in the KKT conditions) to the rate of internal variables. This object calculates the rate of kinematic plastic strain following associative flow rule, i.e. \( \dot{\boldsymbol{K}}_p = - \dot{\gamma} \frac{\partial f}{\partial \boldsymbol{X}} \), where \( \dot{\boldsymbol{K}}_p \) is the kinematic plastic strain, \( \dot{\gamma} \) is the flow rate, \( f \) is the yield function, and \( \boldsymbol{X} \) is the kinematic hardening. </p><details >
<summary >
<code>flow_rate</code> 🇮 Flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>kinematic_hardening_direction</code> 🇮 Direction of associative kinematic hardening which can be calculated using Normality.</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/NX </li>
</ul>
</details>
<details >
<summary >
<code>kinematic_plastic_strain_rate</code> 🇴 Rate of kinematic plastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/Kp_rate </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1AssociativeKinematicPlasticHardening.html">link</a></p>
<h2><a class="anchor" id="associativeplasticflow"></a>
AssociativePlasticFlow</h2>
<p>Map the flow rate (i.e., the consistency parameter in the KKT conditions) to the rate of internal variables. This object calculates the rate of plastic strain following associative flow rule, i.e. \( \dot{\boldsymbol{\varepsilon}}_p = - \dot{\gamma} \frac{\partial f}{\partial \boldsymbol{M}} \), where \( \dot{\boldsymbol{\varepsilon}}_p \) is the plastic strain, \( \dot{\gamma} \) is the flow rate, \( f \) is the yield function, and \( \boldsymbol{M} \) is the Mandel stress. </p><details >
<summary >
<code>flow_direction</code> 🇮 Flow direction which can be calculated using Normality</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/NM </li>
</ul>
</details>
<details >
<summary >
<code>flow_rate</code> 🇮 Flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>plastic_strain_rate</code> 🇴 Rate of plastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/Ep_rate </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1AssociativePlasticFlow.html">link</a></p>
<h2><a class="anchor" id="chabocheplastichardening"></a>
ChabochePlasticHardening</h2>
<p>Map the flow rate (i.e., the consistency parameter in the KKT conditions) to the rate of internal variables. This object defines the non-associative Fredrick-Armstrong kinematic hardening. In the model, back stress is directly treated as an internal variable. Rate of back stress is given as \( \dot{\boldsymbol{X}} = \left( \frac{2}{3} C \frac{\partial f}{\partial \boldsymbol{M}} - g \boldsymbol{X} \right) \dot{\gamma} \). \( \frac{\partial f}{\partial \boldsymbol{M}} \) is the flow direction, \( \dot{\gamma} \) is the flow rate, and \( C \) and \( g \) are material parameters. This object defines the non-associative Chaboche kinematic hardening. In the Chaboche model, back stress is directly treated as an internal variable. Rate of back stress is given as \( \dot{\boldsymbol{X}} = \left( \frac{2}{3} C \frac{\partial f}{\partial \boldsymbol{M}} - g \boldsymbol{X} \right) \dot{\gamma} - A \lVert \boldsymbol{X} \rVert^{a - 1} \boldsymbol{X} \), including kinematic hardening, dynamic recovery, and static recovery. \( \frac{\partial f}{\partial \boldsymbol{M}} \) is the flow direction, \( \dot{\gamma} \) is the flow rate, and \( C \), \( g \), \( A \), and \( a \) are material parameters. </p><details >
<summary >
<code>A</code> 🇵 Static recovery prefactor</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>C</code> 🇵 Kinematic hardening coefficient</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>a</code> 🇵 Static recovery exponent</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>back_stress</code> 🇮 Back stress</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/X </li>
</ul>
</details>
<details >
<summary >
<code>back_stress_rate</code> 🇴 Back stress rate, defaults to back_stress + _rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>flow_direction</code> 🇮 Flow direction</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/NM </li>
</ul>
</details>
<details >
<summary >
<code>flow_rate</code> 🇮 Flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>g</code> 🇵 Dynamic recovery coefficient</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ChabochePlasticHardening.html">link</a></p>
<h2><a class="anchor" id="composedmodel"></a>
ComposedModel</h2>
<p>Compose multiple models together to form a single model. The composed model can then be treated as a new model and composed with others. The <a class="el" href="system-models.html#model-composition">system documentation</a> provides in-depth explanation on how the models are composed together. </p><details >
<summary >
<code>additional_outputs</code> Extra output variables to be extracted from the composed model in addition to the ones identified through dependency resolution.</summary>
<p></p>
<ul>
<li><u>Type</u>: list of variable name </li>
</ul>
</details>
<details >
<summary >
<code>automatic_nonlinear_parameter</code> Whether to automatically add dependent nonlinear parameters</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: true </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling</code> Whether to perform automatic scaling. See neml2::NonlinearSystem::init_scaling for implementation details.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_miter</code> Maximum number of automatic scaling iterations. No error is produced upon reaching the maximum number of scaling iterations, and the scaling matrices obtained at the last iteration are used to scale the nonlinear system.</summary>
<p></p>
<ul>
<li><u>Type</u>: unsigned number</li>
<li><u>Default</u>: 20 </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_tol</code> Tolerance used in iteratively updating the scaling matrices.</summary>
<p></p>
<ul>
<li><u>Type</u>: number</li>
<li><u>Default</u>: 0.01 </li>
</ul>
</details>
<details >
<summary >
<code>models</code> Models being composed together</summary>
<p></p>
<ul>
<li><u>Type</u>: list of string </li>
</ul>
</details>
<details >
<summary >
<code>priority</code> Priorities of models in decreasing order. A model with higher priority will be evaluated first. This is useful for breaking cyclic dependency.</summary>
<p></p>
<ul>
<li><u>Type</u>: list of string </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ComposedModel.html">link</a></p>
<h2><a class="anchor" id="copymillerindex"></a>
CopyMillerIndex</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyquaternion"></a>
CopyQuaternion</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyr2"></a>
CopyR2</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyr3"></a>
CopyR3</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyr4"></a>
CopyR4</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyr5"></a>
CopyR5</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyrot"></a>
CopyRot</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copysffr4"></a>
CopySFFR4</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copysfr3"></a>
CopySFR3</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copysr2"></a>
CopySR2</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyssfr5"></a>
CopySSFR5</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyssr4"></a>
CopySSR4</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyswr4"></a>
CopySWR4</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyscalar"></a>
CopyScalar</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyvec"></a>
CopyVec</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copywr2"></a>
CopyWR2</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copywsr4"></a>
CopyWSR4</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copywwr4"></a>
CopyWWR4</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> 🇮 Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="elasticstrainrate"></a>
ElasticStrainRate</h2>
<p>Calculates the elastic strain rate as \(\dot{\varepsilon} = d - d^p - \varepsilon w + w \varepsilon \) where \( d \) is the deformation rate, \( d^p \) is the plastic deformation rate, \( w \) is the vorticity, and \( \varepsilon \) is the elastic strain. </p><details >
<summary >
<code>deformation_rate</code> 🇮 Name of the deformation rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/deformation_rate </li>
</ul>
</details>
<details >
<summary >
<code>elastic_strain</code> 🇮 Name of the elastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/elastic_strain </li>
</ul>
</details>
<details >
<summary >
<code>elastic_strain_rate</code> 🇴 Name of the elastic strain rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/elastic_strain_rate </li>
</ul>
</details>
<details >
<summary >
<code>plastic_deformation_rate</code> 🇮 Name of the plastic deformation rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/plastic_deformation_rate </li>
</ul>
</details>
<details >
<summary >
<code>vorticity</code> 🇮 Name of the vorticity</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/vorticity </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ElasticStrainRate.html">link</a></p>
<h2><a class="anchor" id="fixorientation"></a>
FixOrientation</h2>
<p>Checks the value of the modified Rodrigues parameter by checking if \( \left\lVert r \right\rVert &gt; t \), with \( t \) a threshold value set to 1.0 by default and replacing all the orientations that exceed this limit with their shadow parameters values. </p><details >
<summary >
<code>input_orientation</code> 🇮 Name of input tensor of orientations to operate on.</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/orientation </li>
</ul>
</details>
<details >
<summary >
<code>output_orientation</code> 🇴 Name of output tensor</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/orientation </li>
</ul>
</details>
<details >
<summary >
<code>threshold</code> Threshold value for translating to the shadow parameters</summary>
<p></p>
<ul>
<li><u>Type</u>: number</li>
<li><u>Default</u>: 1 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1FixOrientation.html">link</a></p>
<h2><a class="anchor" id="fredrickarmstrongplastichardening"></a>
FredrickArmstrongPlasticHardening</h2>
<p>Map the flow rate (i.e., the consistency parameter in the KKT conditions) to the rate of internal variables. This object defines the non-associative Fredrick-Armstrong kinematic hardening. In the model, back stress is directly treated as an internal variable. Rate of back stress is given as \( \dot{\boldsymbol{X}} = \left( \frac{2}{3} C \frac{\partial f}{\partial \boldsymbol{M}} - g \boldsymbol{X} \right) \dot{\gamma} \). \( \frac{\partial f}{\partial \boldsymbol{M}} \) is the flow direction, \( \dot{\gamma} \) is the flow rate, and \( C \) and \( g \) are material parameters. </p><details >
<summary >
<code>C</code> 🇵 Kinematic hardening coefficient</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>back_stress</code> 🇮 Back stress</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/X </li>
</ul>
</details>
<details >
<summary >
<code>back_stress_rate</code> 🇴 Back stress rate, defaults to back_stress + _rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>flow_direction</code> 🇮 Flow direction</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/NM </li>
</ul>
</details>
<details >
<summary >
<code>flow_rate</code> 🇮 Flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>g</code> 🇵 Dynamic recovery coefficient</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1FredrickArmstrongPlasticHardening.html">link</a></p>
<h2><a class="anchor" id="gtnyieldfunction"></a>
GTNYieldFunction</h2>
<p>Gurson-Tvergaard-Needleman yield function for poroplasticity. The yield function is defined as \( f = \left( \frac{\bar{\sigma}}{\sigma_y + k} \right)^2 + 2 q_1 \phi \cosh \left( \frac{1}{2} q_2 \frac{3\sigma_h-\sigma_s}{\sigma_y + k} \right) - \left( q_3 \phi^2 + 1 \right) \), where \( \bar{\sigma} \) is the von Mises stress, \( \sigma_y \) is the yield stress, \( k \) is isotropic hardening, \( \phi \) is the porosity, \( \sigma_h \) is the hydrostatic stress, and \( \sigma_s \) is the void growth back stress (sintering stress). \( q_1 \), \( q_2 \), and \( q_3 \) are parameters controlling the yield mechanisms. </p><details >
<summary >
<code>flow_invariant</code> 🇮 Effective stress driving plastic flow</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/se </li>
</ul>
</details>
<details >
<summary >
<code>isotropic_hardening</code> 🇮 Isotropic hardening</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>poro_invariant</code> 🇮 Effective stress driving porous flow</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/sp </li>
</ul>
</details>
<details >
<summary >
<code>q1</code> 🇵 Parameter controlling the balance/competition between plastic flow and void evolution.</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>q2</code> 🇵 Void evolution rate</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>q3</code> 🇵 Pore pressure</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>void_fraction</code> 🇮 Void fraction (porosity)</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/f </li>
</ul>
</details>
<details >
<summary >
<code>yield_function</code> 🇴 Yield function</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/fp </li>
</ul>
</details>
<details >
<summary >
<code>yield_stress</code> 🇵 Yield stress</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1GTNYieldFunction.html">link</a></p>
<h2><a class="anchor" id="gursoncavitation"></a>
GursonCavitation</h2>
<p>Local mass balance used in conjunction with the GTNYieldFunction, \( \dot{\phi} = (1-\phi) \dot{\varepsilon}_p \). </p><details >
<summary >
<code>plastic_strain_rate</code> 🇮 Plastic strain rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/Ep_rate </li>
</ul>
</details>
<details >
<summary >
<code>void_fraction</code> 🇮 Void fraction (porosity)</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/f </li>
</ul>
</details>
<details >
<summary >
<code>void_fraction_rate</code> 🇴 Rate of void evolution</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/f_rate </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1GursonCavitation.html">link</a></p>
<h2><a class="anchor" id="implicitupdate"></a>
ImplicitUpdate</h2>
<p>Update an implicit model by solving the underlying implicit system of equations. </p><details >
<summary >
<code>implicit_model</code> The implicit model defining the implicit system of equations to be solved</summary>
<p></p>
<ul>
<li><u>Type</u>: string </li>
</ul>
</details>
<details >
<summary >
<code>solver</code> Solver used to solve the implicit system</summary>
<p></p>
<ul>
<li><u>Type</u>: string </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ImplicitUpdate.html">link</a></p>
<h2><a class="anchor" id="isotropicmandelstress"></a>
IsotropicMandelStress</h2>
<p>Map Cauchy stress to Mandel stress For isotropic material under small deformation, the Mandel stress and the Cauchy stress coincide. </p><details >
<summary >
<code>cauchy_stress</code> 🇮 Cauchy stress</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/S </li>
</ul>
</details>
<details >
<summary >
<code>mandel_stress</code> 🇴 Mandel stress</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/M </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1IsotropicMandelStress.html">link</a></p>
<h2><a class="anchor" id="kocksmeckingactivationenergy"></a>
KocksMeckingActivationEnergy</h2>
<p>Calculates the Kocks-Mecking normalized activation as \(g = \frac{kT}{\mu b^3} \log \frac{\dot{\varepsilon}_0}{\dot{\varepsilon}} \) with \( \mu \) the shear modulus, \( k \) the Boltzmann constant, \( T \) the absolute temperature, \( b \) the Burgers vector length, \( \dot{\varepsilon}_0 \) a reference strain rate, and \( \dot{\varepsilon} \) the current strain rate. </p><details >
<summary >
<code>activation_energy</code> 🇴 Output name of the activation energy</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/g </li>
</ul>
</details>
<details >
<summary >
<code>b</code> Magnitude of the Burgers vector</summary>
<p></p>
<ul>
<li><u>Type</u>: number </li>
</ul>
</details>
<details >
<summary >
<code>eps0</code> Reference strain rate</summary>
<p></p>
<ul>
<li><u>Type</u>: number </li>
</ul>
</details>
<details >
<summary >
<code>k</code> The Boltzmann constant</summary>
<p></p>
<ul>
<li><u>Type</u>: number </li>
</ul>
</details>
<details >
<summary >
<code>shear_modulus</code> 🇵 The shear modulus</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>strain_rate</code> 🇮 Name of the effective strain rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/effective_strain_rate </li>
</ul>
</details>
<details >
<summary >
<code>temperature</code> 🇮 Absolute temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/T </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1KocksMeckingActivationEnergy.html">link</a></p>
<h2><a class="anchor" id="kocksmeckingflowswitch"></a>
KocksMeckingFlowSwitch</h2>
<p>Switches between rate independent and rate dependent flow rules based on the value of the Kocks-Mecking normalized activation energy. For activation energies less than the threshold use the rate independent flow rule, for values greater than the threshold use the rate dependent flow rule. This version uses a soft switch between the models, based on a tanh sigmoid function. </p><details >
<summary >
<code>activation_energy</code> 🇮 The input name of the activation energy</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/g </li>
</ul>
</details>
<details >
<summary >
<code>flow_rate</code> 🇴 Output name for the mixed flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>g0</code> 🇵 Critical value of activation energy</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>rate_dependent_flow_rate</code> 🇮 Input name of the rate dependent flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/rd_rate </li>
</ul>
</details>
<details >
<summary >
<code>rate_independent_flow_rate</code> 🇮 Input name of the rate independent flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/ri_rate </li>
</ul>
</details>
<details >
<summary >
<code>sharpness</code> A steepness parameter that controls the tanh mixing of the models. Higher values gives a sharper transition.</summary>
<p></p>
<ul>
<li><u>Type</u>: number</li>
<li><u>Default</u>: 1 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1KocksMeckingFlowSwitch.html">link</a></p>
<h2><a class="anchor" id="kocksmeckingflowviscosity"></a>
KocksMeckingFlowViscosity</h2>
<p>Calculates the temperature-dependent flow viscosity for a Perzyna-type model using the Kocks-Mecking model. The value is \( \eta = \exp{B} \mu \dot{\varepsilon}_0^\frac{-k T A}{\mu b^3} \) with \( \mu \) the shear modulus, \( \dot{\varepsilon}_0 \) a reference strain rate, \( b \) the Burgers vector, \(  k\) the Boltzmann constant, \( T \) absolute temperature, \( A \) the Kocks-Mecking slope parameter, and \( B \) the Kocks-Mecking intercept parameter. </p><details >
<summary >
<code>A</code> 🇵 The Kocks-Mecking slope parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>B</code> 🇵 The Kocks-Mecking intercept parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>b</code> The Burgers vector</summary>
<p></p>
<ul>
<li><u>Type</u>: number </li>
</ul>
</details>
<details >
<summary >
<code>eps0</code> The reference strain rate</summary>
<p></p>
<ul>
<li><u>Type</u>: number </li>
</ul>
</details>
<details >
<summary >
<code>k</code> Boltzmann constant</summary>
<p></p>
<ul>
<li><u>Type</u>: number </li>
</ul>
</details>
<details >
<summary >
<code>shear_modulus</code> 🇵 The shear modulus</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>temperature</code> 🇮 Absolute temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/T </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1KocksMeckingFlowViscosity.html">link</a></p>
<h2><a class="anchor" id="kocksmeckingratesensitivity"></a>
KocksMeckingRateSensitivity</h2>
<p>Calculates the temperature-dependent rate sensitivity for a Perzyna-type model using the Kocks-Mecking model. The value is \( n = \frac{\mu b^3}{k T A} \) with \( \mu \) the shear modulus, \( b \) the Burgers vector, \(  k\) the Boltzmann constant, \( T \) absolute temperature, and \( A \) the Kocks-Mecking slope parameter. </p><details >
<summary >
<code>A</code> 🇵 The Kocks-Mecking slope parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>b</code> The Burgers vector</summary>
<p></p>
<ul>
<li><u>Type</u>: number </li>
</ul>
</details>
<details >
<summary >
<code>k</code> Boltzmann constant</summary>
<p></p>
<ul>
<li><u>Type</u>: number </li>
</ul>
</details>
<details >
<summary >
<code>shear_modulus</code> 🇵 The shear modulus</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>temperature</code> 🇮 Absolute temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/T </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1KocksMeckingRateSensitivity.html">link</a></p>
<h2><a class="anchor" id="kocksmeckingyieldstress"></a>
KocksMeckingYieldStress</h2>
<p>The yield stress given by the Kocks-Mecking model. \( \sigma_y = \exp{C} \mu \) with \( \mu \) the shear modulus and \( C \) the horizontal intercept from the Kocks-Mecking diagram. </p><details >
<summary >
<code>C</code> 🇵 The Kocks-Mecking horizontal intercept</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>shear_modulus</code> 🇵 The shear modulus</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1KocksMeckingYieldStress.html">link</a></p>
<h2><a class="anchor" id="linearisotropicelasticity"></a>
LinearIsotropicElasticity</h2>
<p>Relate elastic strain to stress for linear isotropic material. \( \boldsymbol{\sigma} = K \tr \boldsymbol{\varepsilon}_e + 2 G \text{dev} \boldsymbol{\varepsilon}_e \), where \( K \) and \( G \) are bulk and shear moduli, respectively. For convenience, this object only requests Young's modulus and Poisson's ratio, and handles the Lame parameter conversion behind the scenes. </p><details >
<summary >
<code>compliance</code> Whether the model defines the compliance relationship, i.e., mapping from stress to elastic strain. When set to false (default), the model maps elastic strain to stress.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>poisson_ratio</code> 🇵 Poisson's ratio</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>rate_form</code> Whether the model defines the stress-strain relationship in rate form. When set to true, the model maps elastic strain <em>rate</em> to stress <em>rate</em>.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>strain</code> 🇮 Elastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/Ee </li>
</ul>
</details>
<details >
<summary >
<code>stress</code> 🇴 Stress</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/S </li>
</ul>
</details>
<details >
<summary >
<code>youngs_modulus</code> 🇵 Young's modulus</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearIsotropicElasticity.html">link</a></p>
<h2><a class="anchor" id="linearisotropichardening"></a>
LinearIsotropicHardening</h2>
<p>Map equivalent plastic strain to isotropic hardening following a linear relationship, i.e., \( h = K \varepsilon_p \) where \( K \) is the hardening modulus. </p><details >
<summary >
<code>equivalent_plastic_strain</code> 🇮 Equivalent plastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/ep </li>
</ul>
</details>
<details >
<summary >
<code>hardening_modulus</code> 🇵 Hardening modulus</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>isotropic_hardening</code> 🇴 Isotropic hardening</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/k </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearIsotropicHardening.html">link</a></p>
<h2><a class="anchor" id="linearkinematichardening"></a>
LinearKinematicHardening</h2>
<p>Map kinematic plastic strain to back stress following a linear relationship, i.e., \( \boldsymbol{X} = H \boldsymbol{K}_p \) where \( H \) is the hardening modulus. </p><details >
<summary >
<code>back_stress</code> 🇴 Back stress</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/X </li>
</ul>
</details>
<details >
<summary >
<code>hardening_modulus</code> 🇵 Hardening modulus</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>kinematic_plastic_strain</code> 🇮 Kinematic plastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/Kp </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearKinematicHardening.html">link</a></p>
<h2><a class="anchor" id="linearsinglesliphardeningrule"></a>
LinearSingleSlipHardeningRule</h2>
<p>Simple linear slip system hardening defined by \( \dot{\tau} = \theta \sum_{i=1}^{n_{slip}} \left| \dot{\gamma}_i \right| \) where \( \theta \) is the hardening slope. </p><details >
<summary >
<code>hardening_slope</code> 🇵 Hardening rate</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>slip_hardening</code> 🇮 Name of current values of slip hardening</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/slip_hardening </li>
</ul>
</details>
<details >
<summary >
<code>slip_hardening_rate</code> 🇴 Name of tensor to output the slip system hardening rates into</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/slip_hardening_rate </li>
</ul>
</details>
<details >
<summary >
<code>sum_slip_rates</code> 🇮 Name of tensor containing the sum of the slip rates</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/sum_slip_rates </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearSingleSlipHardeningRule.html">link</a></p>
<h2><a class="anchor" id="millerindexconstantparameter"></a>
MillerIndexConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: MillerIndex 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="millerindexinputparameter"></a>
MillerIndexInputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="mixedcontrolsetup"></a>
MixedControlSetup</h2>
<p>Object to setup a model for mixed stress/strain control. Copies the values of the fixed_values (the input strain or stress) and the mixed_state (the conjugate stress or strain values) into the stress and strain tensors used by the model. </p><details >
<summary >
<code>cauchy_stress</code> 🇴 The name of the Cauchy stress tensor</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/S </li>
</ul>
</details>
<details >
<summary >
<code>control</code> 🇮 The name of the control signal. Values less than the threshold are strain control, greater are stress control</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/control </li>
</ul>
</details>
<details >
<summary >
<code>fixed_values</code> 🇮 The name of the fixed values, i.e. the actual strain or stress values being imposed on the model</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/fixed_values </li>
</ul>
</details>
<details >
<summary >
<code>mixed_state</code> 🇮 The name of the mixed state tensor. This holds the conjugate values to those being controlled</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/mixed_state </li>
</ul>
</details>
<details >
<summary >
<code>strain</code> 🇴 The name of the strain tensor</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/E </li>
</ul>
</details>
<details >
<summary >
<code>threshold</code> The threshold to switch between strain and stress control</summary>
<p></p>
<ul>
<li><u>Type</u>: Tensor 🔗</li>
<li><u>Default</u>: 0.5 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1MixedControlSetup.html">link</a></p>
<h2><a class="anchor" id="normality"></a>
Normality</h2>
<p>Store the first derivatives of a scalar-valued function in given variables, i.e. \( u_i = \dfrac{f(\boldsymbol{v})}{v_i} \). </p><details >
<summary >
<code>from</code> Function arguments to take derivatives w.r.t.</summary>
<p></p>
<ul>
<li><u>Type</u>: list of variable name </li>
</ul>
</details>
<details >
<summary >
<code>function</code> Function to take derivative</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>model</code> The model which evaluates the scalar-valued function</summary>
<p></p>
<ul>
<li><u>Type</u>: string </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variables to store the first derivatives</summary>
<p></p>
<ul>
<li><u>Type</u>: list of variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1Normality.html">link</a></p>
<h2><a class="anchor" id="olevskysnumbereringstress"></a>
OlevskySnumbereringStress</h2>
<p>Define the Olevsky-Skorohod sintering stress to be used in conjunction with poroplasticity yield functions such as the GTNYieldFunction. The sintering stress is defined as \( \sigma_s = 3 \dfrac{\gamma}{r} \phi^2 \), where \( \gamma \) is the surface tension, \( r \) is the size of the particles/powders, and \( \phi \) is the void fraction. </p><details >
<summary >
<code>particle_radius</code> 🇵 Particle radius</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>sintering_stress</code> 🇴 Sintering stress</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/ss </li>
</ul>
</details>
<details >
<summary >
<code>surface_tension</code> 🇵 Surface tension</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>void_fraction</code> 🇮 Void fraction</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/f </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1OlevskySinteringStress.html">link</a></p>
<h2><a class="anchor" id="orientationrate"></a>
OrientationRate</h2>
<p>Defines the rate of the crystal orientations as a spin given by \( \Omega^e = w - w^p - \varepsilon d^p + d^p \varepsilon \) where \( \Omega^e = \dot{Q} Q^T \), \( Q \) is the orientation, \( w \) is the vorticity, \( w^p \) is the plastic vorticity, \( d^p \) is the plastic deformation rate, and \( \varepsilon \) is the elastic stretch. </p><details >
<summary >
<code>elastic_strain</code> 🇮 The name of the elastic strain tensor</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/elastic_strain </li>
</ul>
</details>
<details >
<summary >
<code>orientation_rate</code> 🇴 The name of the orientation rate (spin)</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/orientation_rate </li>
</ul>
</details>
<details >
<summary >
<code>plastic_deformation_rate</code> 🇮 The name of the plastic deformation rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/plastic_deformation_rate </li>
</ul>
</details>
<details >
<summary >
<code>plastic_vorticity</code> 🇮 The name of the plastic vorticity</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/plastic_vorticity </li>
</ul>
</details>
<details >
<summary >
<code>vorticity</code> 🇮 The name of the voriticty tensor</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/vorticity </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1OrientationRate.html">link</a></p>
<h2><a class="anchor" id="perzynaplasticflowrate"></a>
PerzynaPlasticFlowRate</h2>
<p>Perzyna's viscous approximation of the consistent yield envelope (with a power law), i.e. \( \dot{\gamma} = \left( \frac{\left&lt; f \right&gt;}{\eta} \right)^n \), where \( f \) is the yield function, \( \eta \) is the reference stress, and \( n \) is the power-law exponent. </p><details >
<summary >
<code>exponent</code> 🇵 Power-law exponent</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>flow_rate</code> 🇴 Flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>reference_stress</code> 🇵 Reference stress</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>yield_function</code> 🇮 Yield function</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/fp </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1PerzynaPlasticFlowRate.html">link</a></p>
<h2><a class="anchor" id="plasticdeformationrate"></a>
PlasticDeformationRate</h2>
<p>Caclulates the plastic deformation rate as \( d^p = \sum_{i=1}^{n_{slip}} \dot{\gamma}_i Q \operatorname{sym}{\left(d_i \otimes n_i \right)} Q^T \) with \( d^p \) the plastic deformation rate, \( \dot{\gamma}_i \) the slip rate on the ith slip system, \(Q \) the orientation, \( d_i \) the slip system direction, and \( n_i \) the slip system normal. </p><details >
<summary >
<code>crystal_geometry_name</code> The name of the Data object containing the crystallographic information for the material</summary>
<p></p>
<ul>
<li><u>Type</u>: string</li>
<li><u>Default</u>: crystal_geometry </li>
</ul>
</details>
<details >
<summary >
<code>orientation</code> 🇮 The name of the orientation matrix tensor</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/orientation_matrix </li>
</ul>
</details>
<details >
<summary >
<code>plastic_deformation_rate</code> 🇴 The name of the plastic deformation rate tensor</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/plastic_deformation_rate </li>
</ul>
</details>
<details >
<summary >
<code>slip_rates</code> 🇮 The name of the tensor containg the current slip rates</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/slip_rates </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1PlasticDeformationRate.html">link</a></p>
<h2><a class="anchor" id="plasticvorticity"></a>
PlasticVorticity</h2>
<p>Caclulates the plastic vorcitity as \( w^p = \sum_{i=1}^{n_{slip}} \dot{\gamma}_i Q \operatorname{skew}{\left(d_i \otimes n_i \right)} Q^T \) with \( d^p \) the plastic deformation rate, \( \dot{\gamma}_i \) the slip rate on the ith slip system, \(Q \) the orientation, \( d_i \) the slip system direction, and \( n_i \) the slip system normal. </p><details >
<summary >
<code>crystal_geometry_name</code> The name of the Data object containing the crystallographic information for the material</summary>
<p></p>
<ul>
<li><u>Type</u>: string</li>
<li><u>Default</u>: crystal_geometry </li>
</ul>
</details>
<details >
<summary >
<code>orientation</code> 🇮 The name of the orientation matrix tensor</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/orientation_matrix </li>
</ul>
</details>
<details >
<summary >
<code>plastic_vorticity</code> 🇴 The name of the plastic vorticity tensor</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/plastic_vorticity </li>
</ul>
</details>
<details >
<summary >
<code>slip_rates</code> 🇮 The name of the tensor containg the current slip rates</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/slip_rates </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1PlasticVorticity.html">link</a></p>
<h2><a class="anchor" id="powerlawisotropichardeningstaticrecovery"></a>
PowerLawIsotropicHardeningStaticRecovery</h2>
<p>Static recovery for isotropic hardening of the form \( \dot{k} = -\left(\frac{\lVert k \rVert}{\tau}\right)^(n-1) \frac{k}{\tau} \) </p><details >
<summary >
<code>isotropic_hardening</code> 🇮 Isotropic hardening variable</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/k </li>
</ul>
</details>
<details >
<summary >
<code>isotropic_hardening_rate</code> 🇮 Rate of isotropic hardening, defaults to isotropic_hardening + _recovery_rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>n</code> 🇵 Recovery exponent</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>tau</code> 🇵 Recovery rate</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1PowerLawIsotropicHardeningStaticRecovery.html">link</a></p>
<h2><a class="anchor" id="powerlawkinematichardeningstaticrecovery"></a>
PowerLawKinematicHardeningStaticRecovery</h2>
<p>This object defines kinematic hardening static recovery on a backstress termThis object defines kinematic hardening static recovery on a backstress term as \( \dot{X} = - \left(\frac{\lVert X \rVert}{\tau}\right)^(n-1) \frac{X}{\tau} \)where \( n \) is the power law recovery exponent and \(\tau\) is the recovery rate. </p><details >
<summary >
<code>back_stress</code> 🇮 Back stress</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/X </li>
</ul>
</details>
<details >
<summary >
<code>back_stress_rate</code> 🇴 Back stress rate, defaults to back_stress + _recovery_rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>n</code> 🇵 Static recovery exponent</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>tau</code> 🇵 Static recovery rate</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1PowerLawKinematicHardeningStaticRecovery.html">link</a></p>
<h2><a class="anchor" id="powerlawsliprule"></a>
PowerLawSlipRule</h2>
<p>Power law slip rule defined as \( \dot{\gamma}_i = \dot{\gamma}_0 \left| \frac{\tau_i}{\hat{\tau}_i} \right|^{n-1} \frac{\tau_i}{\hat{\tau}_i} \) with \( \dot{\gamma}_i \) the slip rate on system \( i \), \( \tau_i \) the resolved shear, \( \hat{\tau}_i \) the slip system strength, \( n \) the rate senstivity, and \( \dot{\gamma}_0 \) a reference slip rate. </p><details >
<summary >
<code>crystal_geometry_name</code> Name of the Data object containing the crystallographic information</summary>
<p></p>
<ul>
<li><u>Type</u>: string</li>
<li><u>Default</u>: crystal_geometry </li>
</ul>
</details>
<details >
<summary >
<code>gamma0</code> 🇵 Reference slip rate</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>n</code> 🇵 Rate sensitivity exponent</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>resolved_shears</code> 🇮 Name of the resolved shear tensor</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/resolved_shears </li>
</ul>
</details>
<details >
<summary >
<code>slip_rates</code> 🇴 Name of the slip rate tensor</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/slip_rates </li>
</ul>
</details>
<details >
<summary >
<code>slip_strengths</code> 🇮 Name of the tensor containing the slip system strengths</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/slip_strengths </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1PowerLawSlipRule.html">link</a></p>
<h2><a class="anchor" id="quaternionconstantparameter"></a>
QuaternionConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: Quaternion 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="quaternioninputparameter"></a>
QuaternionInputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="r2constantparameter"></a>
R2ConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: R2 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="r2inputparameter"></a>
R2InputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="r3constantparameter"></a>
R3ConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: R3 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="r3inputparameter"></a>
R3InputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="r4constantparameter"></a>
R4ConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: R4 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="r4inputparameter"></a>
R4InputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="r5constantparameter"></a>
R5ConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: R5 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="r5inputparameter"></a>
R5InputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="rateindependentplasticflowconstranumber"></a>
RateIndependentPlasticFlowConstranumber</h2>
<p>Solve the consistent plasticity yield envelope by solving the equivalent complementarity condition </p><p class="formulaDsp">
\[ r = \dot{\gamma} - f^p - \sqrt{{\dot{\gamma}}^2 + {f^p}^2} \]
</p>
 <details >
<summary >
<code>flow_rate</code> 🇮 Flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>yield_function</code> 🇮 Yield function</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/fp </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1RateIndependentPlasticFlowConstraint.html">link</a></p>
<h2><a class="anchor" id="resolvedshear"></a>
ResolvedShear</h2>
<p>Calculates the resolved shears as \( \tau_i = \sigma : Q \operatorname{sym}\left(d_i \otimes n_i \right) Q^T \) where \( \tau_i \) is the resolved shear on slip system i, \( \sigma \) is the Cauchy stress \( Q \) is the orientation matrix, \( d_i \) is the slip direction, and \( n_i \) is the slip system normal. </p><details >
<summary >
<code>crystal_geometry_name</code> The name of the data object with the crystallographic information</summary>
<p></p>
<ul>
<li><u>Type</u>: string</li>
<li><u>Default</u>: crystal_geometry </li>
</ul>
</details>
<details >
<summary >
<code>orientation</code> 🇮 The name of the orientation matrix</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/orientation_matrix </li>
</ul>
</details>
<details >
<summary >
<code>resolved_shears</code> 🇴 The name of the resolved shears</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/resolved_shears </li>
</ul>
</details>
<details >
<summary >
<code>stress</code> 🇮 The name of the Cauchy stress tensor</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/cauchy_stress </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ResolvedShear.html">link</a></p>
<h2><a class="anchor" id="rotconstantparameter"></a>
RotConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: Rot 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="rotinputparameter"></a>
RotInputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="rotationmatrix"></a>
RotationMatrix</h2>
<p>Convert a Rot (rotation represented in Rodrigues format) to R2 (a full rotation matrix). </p><details >
<summary >
<code>from</code> 🇮 Rot to convert</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>to</code> 🇴 R2 to store the resulting rotation matrix</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1RotationMatrix.html">link</a></p>
<h2><a class="anchor" id="sffr4constantparameter"></a>
SFFR4ConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: SFFR4 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="sffr4inputparameter"></a>
SFFR4InputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="sfr3constantparameter"></a>
SFR3ConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: SFR3 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="sfr3inputparameter"></a>
SFR3InputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="sr2backwardeulertimeintegration"></a>
SR2BackwardEulerTimeIntegration</h2>
<p>Define the backward Euler time integration residual \( r = s - s_n - (t - t_n) \dot{s} \), where \(s\) is the variable being integrated, \(\dot{s}\) is the variable rate, and \(t\) is time. Subscripts \(n\) denote quantities from the previous time step. </p><details >
<summary >
<code>automatic_scaling</code> Whether to perform automatic scaling. See neml2::NonlinearSystem::init_scaling for implementation details.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_miter</code> Maximum number of automatic scaling iterations. No error is produced upon reaching the maximum number of scaling iterations, and the scaling matrices obtained at the last iteration are used to scale the nonlinear system.</summary>
<p></p>
<ul>
<li><u>Type</u>: unsigned number</li>
<li><u>Default</u>: 20 </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_tol</code> Tolerance used in iteratively updating the scaling matrices.</summary>
<p></p>
<ul>
<li><u>Type</u>: number</li>
<li><u>Default</u>: 0.01 </li>
</ul>
</details>
<details >
<summary >
<code>rate</code> 🇮 Variable rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>time</code> 🇮 Time</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> 🇮 Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1BackwardEulerTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="sr2constantparameter"></a>
SR2ConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: SR2 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="sr2forwardeulertimeintegration"></a>
SR2ForwardEulerTimeIntegration</h2>
<p>Perform forward Euler time integration defined as \( s = s_n + (t - t_n) \dot{s} \), where \(s\) is the variable being integrated, \(\dot{s}\) is the variable rate, and \(t\) is time. Subscripts \(n\) denote quantities from the previous time step. </p><details >
<summary >
<code>rate</code> 🇮 Variable rate of change</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>time</code> 🇮 Time</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> 🇴 Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ForwardEulerTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="sr2inputparameter"></a>
SR2InputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="sr2invariant"></a>
SR2Invariant</h2>
<p>Calculate the invariant of a symmetric second order tensor (of type SR2). </p><details >
<summary >
<code>invariant</code> 🇴 Invariant</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>invariant_type</code> Type of invariant. Options are: INVALID EFFECTIVE_STRAIN VONMISES I2 I1 </summary>
<p></p>
<ul>
<li><u>Type</u>: EnumSelection</li>
<li><u>Default</u>: INVALID </li>
</ul>
</details>
<details >
<summary >
<code>tensor</code> 🇮 SR2 which is used to calculate the invariant of</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1SR2Invariant.html">link</a></p>
<h2><a class="anchor" id="sr2linearcombination"></a>
SR2LinearCombination</h2>
<p>Calculate linear combination of multiple SR2 tensors as \( u = c_i v_i \) (Einstein summation assumed), where \( c_i \) are the coefficients, and \( v_i \) are the variables to be summed. </p><details >
<summary >
<code>coefficients</code> 🇵 Weights associated with each variable</summary>
<p></p>
<ul>
<li><u>Type</u>: list of Scalar 🔗</li>
<li><u>Default</u>: 1 </li>
</ul>
</details>
<details >
<summary >
<code>coefficients_as_parameters</code> By default, the coefficients are declared as buffers. Set this option to true to declare them as (trainable) parameters.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>from_var</code> SR2 tensors to be summed</summary>
<p></p>
<ul>
<li><u>Type</u>: list of variable name </li>
</ul>
</details>
<details >
<summary >
<code>to_var</code> 🇴 The sum</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearCombination.html">link</a></p>
<h2><a class="anchor" id="sr2linearinterpolation"></a>
SR2LinearInterpolation</h2>
<p>Interpolate a SR2 as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> 🇮 Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> SR2 defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: SR2 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="sr2twostagethermalannealing"></a>
SR2TwoStageThermalAnnealing</h2>
<p>Thermal annealing recovery for a hardening variable of type SR2.For temperatures below \( T_1 \) the model keeps the base model hardenign rate.For temperatures above \(T_1\) but below \(T_2 \) the model zeros the hardening rate.For temperatures above \(T_2\) the model replaces the hardening rate with \( \dot{h} = \frac{-h}{\tau} \) where \( \tau \) is the rate of recovery. </p><details >
<summary >
<code>T1</code> 🇵 First stage annealing temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>T2</code> 🇵 Second stage annealing temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>base</code> 🇮 Underlying base hardening variable</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>base_rate</code> 🇮 Base hardening rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>modified_rate</code> 🇴 Output for the modified hardening rate.</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>tau</code> 🇵 Recovery rate for second stage annealing.</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>temperature</code> 🇮 Temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/T </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1TwoStageThermalAnnealing.html">link</a></p>
<h2><a class="anchor" id="sr2variablerate"></a>
SR2VariableRate</h2>
<p>Calculate the first order discrete time derivative of a variable as \( \dot{f} = \frac{f-f_n}{t-t_n} \), where \( f \) is the force variable, and \( t \) is time. </p><details >
<summary >
<code>rate</code> 🇴 The variable's rate of change</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>time</code> 🇮 Time</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> 🇮 The variable to take time derivative with</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1VariableRate.html">link</a></p>
<h2><a class="anchor" id="ssfr5constantparameter"></a>
SSFR5ConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: SSFR5 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="ssfr5inputparameter"></a>
SSFR5InputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="ssr4constantparameter"></a>
SSR4ConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: SSR4 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="ssr4inputparameter"></a>
SSR4InputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="swr4constantparameter"></a>
SWR4ConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: SWR4 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="swr4inputparameter"></a>
SWR4InputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="scalarbackwardeulertimeintegration"></a>
ScalarBackwardEulerTimeIntegration</h2>
<p>Define the backward Euler time integration residual \( r = s - s_n - (t - t_n) \dot{s} \), where \(s\) is the variable being integrated, \(\dot{s}\) is the variable rate, and \(t\) is time. Subscripts \(n\) denote quantities from the previous time step. </p><details >
<summary >
<code>automatic_scaling</code> Whether to perform automatic scaling. See neml2::NonlinearSystem::init_scaling for implementation details.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_miter</code> Maximum number of automatic scaling iterations. No error is produced upon reaching the maximum number of scaling iterations, and the scaling matrices obtained at the last iteration are used to scale the nonlinear system.</summary>
<p></p>
<ul>
<li><u>Type</u>: unsigned number</li>
<li><u>Default</u>: 20 </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_tol</code> Tolerance used in iteratively updating the scaling matrices.</summary>
<p></p>
<ul>
<li><u>Type</u>: number</li>
<li><u>Default</u>: 0.01 </li>
</ul>
</details>
<details >
<summary >
<code>rate</code> 🇮 Variable rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>time</code> 🇮 Time</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> 🇮 Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1BackwardEulerTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="scalarconstantparameter"></a>
ScalarConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="scalarforwardeulertimeintegration"></a>
ScalarForwardEulerTimeIntegration</h2>
<p>Perform forward Euler time integration defined as \( s = s_n + (t - t_n) \dot{s} \), where \(s\) is the variable being integrated, \(\dot{s}\) is the variable rate, and \(t\) is time. Subscripts \(n\) denote quantities from the previous time step. </p><details >
<summary >
<code>rate</code> 🇮 Variable rate of change</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>time</code> 🇮 Time</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> 🇴 Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ForwardEulerTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="scalarinputparameter"></a>
ScalarInputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="scalarlinearcombination"></a>
ScalarLinearCombination</h2>
<p>Calculate linear combination of multiple Scalar tensors as \( u = c_i v_i \) (Einstein summation assumed), where \( c_i \) are the coefficients, and \( v_i \) are the variables to be summed. </p><details >
<summary >
<code>coefficients</code> 🇵 Weights associated with each variable</summary>
<p></p>
<ul>
<li><u>Type</u>: list of Scalar 🔗</li>
<li><u>Default</u>: 1 </li>
</ul>
</details>
<details >
<summary >
<code>coefficients_as_parameters</code> By default, the coefficients are declared as buffers. Set this option to true to declare them as (trainable) parameters.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>from_var</code> Scalar tensors to be summed</summary>
<p></p>
<ul>
<li><u>Type</u>: list of variable name </li>
</ul>
</details>
<details >
<summary >
<code>to_var</code> 🇴 The sum</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearCombination.html">link</a></p>
<h2><a class="anchor" id="scalarlinearinterpolation"></a>
ScalarLinearInterpolation</h2>
<p>Interpolate a Scalar as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> 🇮 Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> Scalar defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="scalartwostagethermalannealing"></a>
ScalarTwoStageThermalAnnealing</h2>
<p>Thermal annealing recovery for a hardening variable of type Scalar.For temperatures below \( T_1 \) the model keeps the base model hardenign rate.For temperatures above \(T_1\) but below \(T_2 \) the model zeros the hardening rate.For temperatures above \(T_2\) the model replaces the hardening rate with \( \dot{h} = \frac{-h}{\tau} \) where \( \tau \) is the rate of recovery. </p><details >
<summary >
<code>T1</code> 🇵 First stage annealing temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>T2</code> 🇵 Second stage annealing temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>base</code> 🇮 Underlying base hardening variable</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>base_rate</code> 🇮 Base hardening rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>modified_rate</code> 🇴 Output for the modified hardening rate.</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>tau</code> 🇵 Recovery rate for second stage annealing.</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>temperature</code> 🇮 Temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/T </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1TwoStageThermalAnnealing.html">link</a></p>
<h2><a class="anchor" id="scalarvariablerate"></a>
ScalarVariableRate</h2>
<p>Calculate the first order discrete time derivative of a variable as \( \dot{f} = \frac{f-f_n}{t-t_n} \), where \( f \) is the force variable, and \( t \) is time. </p><details >
<summary >
<code>rate</code> 🇴 The variable's rate of change</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>time</code> 🇮 Time</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> 🇮 The variable to take time derivative with</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1VariableRate.html">link</a></p>
<h2><a class="anchor" id="singleslipstrengthmap"></a>
SingleSlipStrengthMap</h2>
<p>Calculates the slip system strength for all slip systems as \( \hat{\tau}_i = \bar{\tau} + \tau_0 \) where \( \hat{\tau}_i \) is the strength for slip system i, \( \bar{\tau} \) is an evolving slip system strength (one value of all systems), defined by another object, and \( \tau_0 \) is a constant strength. </p><details >
<summary >
<code>constant_strength</code> 🇵 The constant slip system strength</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>crystal_geometry_name</code> Name of the Data object containing the crystallographic information</summary>
<p></p>
<ul>
<li><u>Type</u>: string</li>
<li><u>Default</u>: crystal_geometry </li>
</ul>
</details>
<details >
<summary >
<code>slip_hardening</code> 🇮 The name of the evovling, scalar strength</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/slip_hardening </li>
</ul>
</details>
<details >
<summary >
<code>slip_strengths</code> 🇴 Name of the slip system strengths</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/slip_strengths </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1SingleSlipStrengthMap.html">link</a></p>
<h2><a class="anchor" id="slopesaturationvoceisotropichardening"></a>
SlopeSaturationVoceIsotropicHardening</h2>
<p>SlopeSaturationVoce isotropic hardening model, \( \dot{h} = \theta_0 \left(1 - \frac{h}{R} \right) \varepsilon_p \), where \( R \) is the isotropic hardening upon saturation, and \( \theta_0 \) is the initial hardening rate. </p><details >
<summary >
<code>flow_rate</code> 🇮 Flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>initial_hardening_rate</code> 🇵 Initial hardening rate</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>isotropic_hardening</code> 🇮 Isotropic hardening variable</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/k </li>
</ul>
</details>
<details >
<summary >
<code>isotropic_hardening_rate</code> 🇮 Rate of isotropic hardening, defaults to isotropic_hardening + _rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>saturated_hardening</code> 🇵 Saturated isotropic hardening</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1SlopeSaturationVoceIsotropicHardening.html">link</a></p>
<h2><a class="anchor" id="sumsliprates"></a>
SumSlipRates</h2>
<p>Calculates the sum of the absolute value of all the slip rates as \( \sum_{i=1}^{n_{slip}} \left| \dot{\gamma}_i \right| \). </p><details >
<summary >
<code>crystal_geometry_name</code> The name of the Data object containing the crystallographic information</summary>
<p></p>
<ul>
<li><u>Type</u>: string</li>
<li><u>Default</u>: crystal_geometry </li>
</ul>
</details>
<details >
<summary >
<code>slip_rates</code> 🇮 The name of individual slip rates</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/slip_rates </li>
</ul>
</details>
<details >
<summary >
<code>sum_slip_rates</code> 🇴 The outut name for the scalar sum of the slip rates</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/sum_slip_rates </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1SumSlipRates.html">link</a></p>
<h2><a class="anchor" id="thermaleigenstrain"></a>
ThermalEigenstrain</h2>
<p>Define the (cummulative, as opposed to instantaneous) linear isotropic thermal eigenstrain, i.e. \( \boldsymbol{\varepsilon}_T = \alpha (T - T_0) \boldsymbol{I} \), where \( \alpha \) is the coefficient of thermal expansion (CTE), \( T \) is the temperature, and \( T_0 \) is the reference (stress-free) temperature. </p><details >
<summary >
<code>CTE</code> 🇵 Coefficient of thermal expansion</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>eigenstrain</code> 🇴 Eigenstrain</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/Eg </li>
</ul>
</details>
<details >
<summary >
<code>reference_temperature</code> 🇧 Reference (stress-free) temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>temperature</code> 🇮 Temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/T </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ThermalEigenstrain.html">link</a></p>
<h2><a class="anchor" id="vecbackwardeulertimeintegration"></a>
VecBackwardEulerTimeIntegration</h2>
<p>Define the backward Euler time integration residual \( r = s - s_n - (t - t_n) \dot{s} \), where \(s\) is the variable being integrated, \(\dot{s}\) is the variable rate, and \(t\) is time. Subscripts \(n\) denote quantities from the previous time step. </p><details >
<summary >
<code>automatic_scaling</code> Whether to perform automatic scaling. See neml2::NonlinearSystem::init_scaling for implementation details.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_miter</code> Maximum number of automatic scaling iterations. No error is produced upon reaching the maximum number of scaling iterations, and the scaling matrices obtained at the last iteration are used to scale the nonlinear system.</summary>
<p></p>
<ul>
<li><u>Type</u>: unsigned number</li>
<li><u>Default</u>: 20 </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_tol</code> Tolerance used in iteratively updating the scaling matrices.</summary>
<p></p>
<ul>
<li><u>Type</u>: number</li>
<li><u>Default</u>: 0.01 </li>
</ul>
</details>
<details >
<summary >
<code>rate</code> 🇮 Variable rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>time</code> 🇮 Time</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> 🇮 Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1BackwardEulerTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="vecconstantparameter"></a>
VecConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: Vec 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="vecforwardeulertimeintegration"></a>
VecForwardEulerTimeIntegration</h2>
<p>Perform forward Euler time integration defined as \( s = s_n + (t - t_n) \dot{s} \), where \(s\) is the variable being integrated, \(\dot{s}\) is the variable rate, and \(t\) is time. Subscripts \(n\) denote quantities from the previous time step. </p><details >
<summary >
<code>rate</code> 🇮 Variable rate of change</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>time</code> 🇮 Time</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> 🇴 Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ForwardEulerTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="vecinputparameter"></a>
VecInputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="veclinearcombination"></a>
VecLinearCombination</h2>
<p>Calculate linear combination of multiple Vec tensors as \( u = c_i v_i \) (Einstein summation assumed), where \( c_i \) are the coefficients, and \( v_i \) are the variables to be summed. </p><details >
<summary >
<code>coefficients</code> 🇵 Weights associated with each variable</summary>
<p></p>
<ul>
<li><u>Type</u>: list of Scalar 🔗</li>
<li><u>Default</u>: 1 </li>
</ul>
</details>
<details >
<summary >
<code>coefficients_as_parameters</code> By default, the coefficients are declared as buffers. Set this option to true to declare them as (trainable) parameters.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>from_var</code> Vec tensors to be summed</summary>
<p></p>
<ul>
<li><u>Type</u>: list of variable name </li>
</ul>
</details>
<details >
<summary >
<code>to_var</code> 🇴 The sum</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearCombination.html">link</a></p>
<h2><a class="anchor" id="veclinearinterpolation"></a>
VecLinearInterpolation</h2>
<p>Interpolate a Vec as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> 🇮 Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> Vec defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Vec 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="vecvariablerate"></a>
VecVariableRate</h2>
<p>Calculate the first order discrete time derivative of a variable as \( \dot{f} = \frac{f-f_n}{t-t_n} \), where \( f \) is the force variable, and \( t \) is time. </p><details >
<summary >
<code>rate</code> 🇴 The variable's rate of change</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>time</code> 🇮 Time</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> 🇮 The variable to take time derivative with</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1VariableRate.html">link</a></p>
<h2><a class="anchor" id="voceisotropichardening"></a>
VoceIsotropicHardening</h2>
<p>Voce isotropic hardening model, \( h = R \left[ 1 - \exp(-d \varepsilon_p) \right] \), where \( R \) is the isotropic hardening upon saturation, and \( d \) is the hardening rate. </p><details >
<summary >
<code>equivalent_plastic_strain</code> 🇮 Equivalent plastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/ep </li>
</ul>
</details>
<details >
<summary >
<code>isotropic_hardening</code> 🇴 Isotropic hardening</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/k </li>
</ul>
</details>
<details >
<summary >
<code>saturated_hardening</code> 🇵 Saturated isotropic hardening</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>saturation_rate</code> 🇵 Hardening saturation rate</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1VoceIsotropicHardening.html">link</a></p>
<h2><a class="anchor" id="vocesinglesliphardeningrule"></a>
VoceSingleSlipHardeningRule</h2>
<p>Voce hardening for a SingleSlipStrength type model defined by \( \dot{\tau} = \theta_0 \left( 1 - \frac{\tau}{\tau_f} \right) \sum_{i=1}^{n_{slip}} \left| \dot{\gamma}_i \right| \) where \( \theta_0 \) is the initial rate of work hardening, \( \tau_f \) is the saturated, maximum value of the slip system strength, and \( \dot{\gamma}_i \) is the slip rate on each system. </p><details >
<summary >
<code>initial_slope</code> 🇵 The initial rate of hardening</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>saturated_hardening</code> 🇵 The final, saturated value of the slip system strength</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<details >
<summary >
<code>slip_hardening</code> 🇮 Name of current values of slip hardening</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/slip_hardening </li>
</ul>
</details>
<details >
<summary >
<code>slip_hardening_rate</code> 🇴 Name of tensor to output the slip system hardening rates into</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/slip_hardening_rate </li>
</ul>
</details>
<details >
<summary >
<code>sum_slip_rates</code> 🇮 Name of tensor containing the sum of the slip rates</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/sum_slip_rates </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1VoceSingleSlipHardeningRule.html">link</a></p>
<h2><a class="anchor" id="wr2constantparameter"></a>
WR2ConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: WR2 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="wr2explicitexponentialtimeintegration"></a>
WR2ExplicitExponentialTimeIntegration</h2>
<p>Perform explicit discrete exponential time integration of a rotation. The update can be written as \( s = \exp\left[ (t-t_n)\dot{s}\right] \circ s_n \), where \( \circ \) denotes the rotation operator. </p><details >
<summary >
<code>rate</code> 🇮 Variable rate of change</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>time</code> 🇮 Time</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> 🇴 Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1WR2ExplicitExponentialTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="wr2implicitexponentialtimeintegration"></a>
WR2ImplicitExponentialTimeIntegration</h2>
<p>Define the implicit discrete exponential time integration residual of a rotation variable. The residual can be written as \( r = s - \exp\left[ (t-t_n)\dot{s}\right] \circ s_n \), where \( \circ \) denotes the rotation operator. </p><details >
<summary >
<code>automatic_scaling</code> Whether to perform automatic scaling. See neml2::NonlinearSystem::init_scaling for implementation details.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_miter</code> Maximum number of automatic scaling iterations. No error is produced upon reaching the maximum number of scaling iterations, and the scaling matrices obtained at the last iteration are used to scale the nonlinear system.</summary>
<p></p>
<ul>
<li><u>Type</u>: unsigned number</li>
<li><u>Default</u>: 20 </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_tol</code> Tolerance used in iteratively updating the scaling matrices.</summary>
<p></p>
<ul>
<li><u>Type</u>: number</li>
<li><u>Default</u>: 0.01 </li>
</ul>
</details>
<details >
<summary >
<code>rate</code> 🇮 Variable rate</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>time</code> 🇮 Time</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: forces/t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> 🇮 Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1WR2ImplicitExponentialTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="wr2inputparameter"></a>
WR2InputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="wsr4constantparameter"></a>
WSR4ConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: WSR4 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="wsr4inputparameter"></a>
WSR4InputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="wwr4constantparameter"></a>
WWR4ConstantParameter</h2>
<p>A parameter that is just a constant value, generally used to refer to a parameter in more than one downstream object. </p><details >
<summary >
<code>value</code> 🇵 The constant value of the parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: WWR4 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ConstantParameter.html">link</a></p>
<h2><a class="anchor" id="wwr4inputparameter"></a>
WWR4InputParameter</h2>
<p>A parameter that is defined through an input variable. This essentially converts a nonlinear parameter to an input variable </p><details >
<summary >
<code>from</code> 🇮 The input variable that defines this nonlinear parameter</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1InputParameter.html">link</a></p>
<h2><a class="anchor" id="yieldfunction"></a>
YieldFunction</h2>
<p>Classical macroscale plasticity yield function, \( f = \bar{\sigma} - \sigma_y - h \), where \( \bar{\sigma} \) is the effective stress, \( \sigma_y \) is the yield stress, and \( h \) is the isotropic hardening. </p><details >
<summary >
<code>effective_stress</code> 🇮 Effective stress</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/s </li>
</ul>
</details>
<details >
<summary >
<code>isotropic_hardening</code> 🇮 Isotropic hardening</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name </li>
</ul>
</details>
<details >
<summary >
<code>yield_function</code> 🇴 Yield function</summary>
<p></p>
<ul>
<li><u>Type</u>: variable name</li>
<li><u>Default</u>: state/internal/fp </li>
</ul>
</details>
<details >
<summary >
<code>yield_stress</code> 🇵 Yield stress</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar 🔗 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1YieldFunction.html">link</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
