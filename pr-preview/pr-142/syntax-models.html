<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NEML2: [Models]</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams','[tex]/physics','[tex]/boldsymbol']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams','physics','boldsymbol']
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">NEML2<span id="projectnumber">&#160;1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('syntax-models.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">[Models]</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md30">Available objects and their input file syntax</a><ul><li class="level2"><a href="#arrheniusparameter">ArrheniusParameter</a></li>
<li class="level2"><a href="#associativeisotropicplastichardening">AssociativeIsotropicPlasticHardening</a></li>
<li class="level2"><a href="#associativekinematicplastichardening">AssociativeKinematicPlasticHardening</a></li>
<li class="level2"><a href="#associativeplasticflow">AssociativePlasticFlow</a></li>
<li class="level2"><a href="#chabocheplastichardening">ChabochePlasticHardening</a></li>
<li class="level2"><a href="#composedmodel">ComposedModel</a></li>
<li class="level2"><a href="#copymillerindex">CopyMillerIndex</a></li>
<li class="level2"><a href="#copyquaternion">CopyQuaternion</a></li>
<li class="level2"><a href="#copyr2">CopyR2</a></li>
<li class="level2"><a href="#copyr3">CopyR3</a></li>
<li class="level2"><a href="#copyr4">CopyR4</a></li>
<li class="level2"><a href="#copyr5">CopyR5</a></li>
<li class="level2"><a href="#copyrot">CopyRot</a></li>
<li class="level2"><a href="#copysffr4">CopySFFR4</a></li>
<li class="level2"><a href="#copysfr3">CopySFR3</a></li>
<li class="level2"><a href="#copysr2">CopySR2</a></li>
<li class="level2"><a href="#copyssfr5">CopySSFR5</a></li>
<li class="level2"><a href="#copyssr4">CopySSR4</a></li>
<li class="level2"><a href="#copyswr4">CopySWR4</a></li>
<li class="level2"><a href="#copyscalar">CopyScalar</a></li>
<li class="level2"><a href="#copyvec">CopyVec</a></li>
<li class="level2"><a href="#copywr2">CopyWR2</a></li>
<li class="level2"><a href="#copywsr4">CopyWSR4</a></li>
<li class="level2"><a href="#copywwr4">CopyWWR4</a></li>
<li class="level2"><a href="#elasticstrain">ElasticStrain</a></li>
<li class="level2"><a href="#elasticstrainrate">ElasticStrainRate</a></li>
<li class="level2"><a href="#fixorientation">FixOrientation</a></li>
<li class="level2"><a href="#gtnyieldfunction">GTNYieldFunction</a></li>
<li class="level2"><a href="#gursoncavitation">GursonCavitation</a></li>
<li class="level2"><a href="#implicitupdate">ImplicitUpdate</a></li>
<li class="level2"><a href="#isotropicmandelstress">IsotropicMandelStress</a></li>
<li class="level2"><a href="#linearisotropicelasticity">LinearIsotropicElasticity</a></li>
<li class="level2"><a href="#linearisotropichardening">LinearIsotropicHardening</a></li>
<li class="level2"><a href="#linearkinematichardening">LinearKinematicHardening</a></li>
<li class="level2"><a href="#linearsinglesliphardeningrule">LinearSingleSlipHardeningRule</a></li>
<li class="level2"><a href="#millerindexlinearinterpolation">MillerIndexLinearInterpolation</a></li>
<li class="level2"><a href="#normality">Normality</a></li>
<li class="level2"><a href="#olevskysinteringstress">OlevskySinteringStress</a></li>
<li class="level2"><a href="#orientationrate">OrientationRate</a></li>
<li class="level2"><a href="#overstress">OverStress</a></li>
<li class="level2"><a href="#perzynaplasticflowrate">PerzynaPlasticFlowRate</a></li>
<li class="level2"><a href="#plasticdeformationrate">PlasticDeformationRate</a></li>
<li class="level2"><a href="#plasticvorticity">PlasticVorticity</a></li>
<li class="level2"><a href="#powerlawsliprule">PowerLawSlipRule</a></li>
<li class="level2"><a href="#quaternionlinearinterpolation">QuaternionLinearInterpolation</a></li>
<li class="level2"><a href="#r2linearinterpolation">R2LinearInterpolation</a></li>
<li class="level2"><a href="#r3linearinterpolation">R3LinearInterpolation</a></li>
<li class="level2"><a href="#r4linearinterpolation">R4LinearInterpolation</a></li>
<li class="level2"><a href="#r5linearinterpolation">R5LinearInterpolation</a></li>
<li class="level2"><a href="#rateindependentplasticflowconstraint">RateIndependentPlasticFlowConstraint</a></li>
<li class="level2"><a href="#resolvedshear">ResolvedShear</a></li>
<li class="level2"><a href="#rotlinearinterpolation">RotLinearInterpolation</a></li>
<li class="level2"><a href="#rotationmatrix">RotationMatrix</a></li>
<li class="level2"><a href="#sffr4linearinterpolation">SFFR4LinearInterpolation</a></li>
<li class="level2"><a href="#sfr3linearinterpolation">SFR3LinearInterpolation</a></li>
<li class="level2"><a href="#sr2backwardeulertimeintegration">SR2BackwardEulerTimeIntegration</a></li>
<li class="level2"><a href="#sr2forcerate">SR2ForceRate</a></li>
<li class="level2"><a href="#sr2forwardeulertimeintegration">SR2ForwardEulerTimeIntegration</a></li>
<li class="level2"><a href="#sr2invariant">SR2Invariant</a></li>
<li class="level2"><a href="#sr2linearinterpolation">SR2LinearInterpolation</a></li>
<li class="level2"><a href="#sr2staterate">SR2StateRate</a></li>
<li class="level2"><a href="#sr2summodel">SR2SumModel</a></li>
<li class="level2"><a href="#ssfr5linearinterpolation">SSFR5LinearInterpolation</a></li>
<li class="level2"><a href="#ssr4linearinterpolation">SSR4LinearInterpolation</a></li>
<li class="level2"><a href="#swr4linearinterpolation">SWR4LinearInterpolation</a></li>
<li class="level2"><a href="#scalarbackwardeulertimeintegration">ScalarBackwardEulerTimeIntegration</a></li>
<li class="level2"><a href="#scalarforcerate">ScalarForceRate</a></li>
<li class="level2"><a href="#scalarforwardeulertimeintegration">ScalarForwardEulerTimeIntegration</a></li>
<li class="level2"><a href="#scalarlinearinterpolation">ScalarLinearInterpolation</a></li>
<li class="level2"><a href="#scalarstaterate">ScalarStateRate</a></li>
<li class="level2"><a href="#scalarsummodel">ScalarSumModel</a></li>
<li class="level2"><a href="#singleslipstrengthmap">SingleSlipStrengthMap</a></li>
<li class="level2"><a href="#sumsliprates">SumSlipRates</a></li>
<li class="level2"><a href="#thermaleigenstrain">ThermalEigenstrain</a></li>
<li class="level2"><a href="#totalstrain">TotalStrain</a></li>
<li class="level2"><a href="#vecbackwardeulertimeintegration">VecBackwardEulerTimeIntegration</a></li>
<li class="level2"><a href="#veclinearinterpolation">VecLinearInterpolation</a></li>
<li class="level2"><a href="#voceisotropichardening">VoceIsotropicHardening</a></li>
<li class="level2"><a href="#vocesinglesliphardeningrule">VoceSingleSlipHardeningRule</a></li>
<li class="level2"><a href="#wr2explicitexponentialtimeintegration">WR2ExplicitExponentialTimeIntegration</a></li>
<li class="level2"><a href="#wr2implicitexponentialtimeintegration">WR2ImplicitExponentialTimeIntegration</a></li>
<li class="level2"><a href="#wr2linearinterpolation">WR2LinearInterpolation</a></li>
<li class="level2"><a href="#wsr4linearinterpolation">WSR4LinearInterpolation</a></li>
<li class="level2"><a href="#wwr4linearinterpolation">WWR4LinearInterpolation</a></li>
<li class="level2"><a href="#yieldfunction">YieldFunction</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_content_2syntax_2models"></a></p>
<h1><a class="anchor" id="autotoc_md30"></a>
Available objects and their input file syntax</h1>
<p>Refer to <a class="el" href="system-models.html">System Documentation</a> for detailed explanation about this system.</p>
<h2><a class="anchor" id="arrheniusparameter"></a>
ArrheniusParameter</h2>
<p>Define the nonlinear parameter as a function of temperature according to the Arrhenius law \( p = p_0 \exp \left( -\frac{Q}{RT} \right) \), where \( p_0 \) is the reference value, \( Q \) is the activation energy, \( R \) is the ideal gas constant, and \( T \) is the temperature. </p><details >
<summary >
<code>activation_energy</code> Activation energy</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>ideal_gas_constant</code> The ideal gas constant</summary>
<p></p>
<ul>
<li><u>Type</u>: double </li>
</ul>
</details>
<details >
<summary >
<code>reference_value</code> Reference value</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>temperature</code> Temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: forces/T </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ArrheniusParameter.html">link</a></p>
<h2><a class="anchor" id="associativeisotropicplastichardening"></a>
AssociativeIsotropicPlasticHardening</h2>
<p>Map the flow rate (i.e., the consistency parameter in the KKT conditions) to the rate of internal variables. This object calculates the rate of equivalent plastic strain following associative flow rule, i.e. \( \dot{\varepsilon}_p = - \dot{\gamma} \frac{\partial f}{\partial k} \), where \( \dot{\varepsilon}_p \) is the equivalent plastic strain, \( \dot{\gamma} \) is the flow rate, \( f \) is the yield function, and \( k \) is the isotropic hardening. </p><details >
<summary >
<code>equivalent_plastic_strain_rate</code> Rate of equivalent plastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/ep_rate </li>
</ul>
</details>
<details >
<summary >
<code>flow_rate</code> Flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>isotropic_hardening_direction</code> Direction of associative isotropic hardening which can be calculated using Normality.</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/Nk </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1AssociativeIsotropicPlasticHardening.html">link</a></p>
<h2><a class="anchor" id="associativekinematicplastichardening"></a>
AssociativeKinematicPlasticHardening</h2>
<p>Map the flow rate (i.e., the consistency parameter in the KKT conditions) to the rate of internal variables. This object calculates the rate of kinematic plastic strain following associative flow rule, i.e. \( \dot{\boldsymbol{K}}_p = - \dot{\gamma} \frac{\partial f}{\partial \boldsymbol{X}} \), where \( \dot{\boldsymbol{K}}_p \) is the kinematic plastic strain, \( \dot{\gamma} \) is the flow rate, \( f \) is the yield function, and \( \boldsymbol{X} \) is the kinematic hardening. </p><details >
<summary >
<code>flow_rate</code> Flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>kinematic_hardening_direction</code> Direction of associative kinematic hardening which can be calculated using Normality.</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/NX </li>
</ul>
</details>
<details >
<summary >
<code>kinematic_plastic_strain_rate</code> Rate of kinematic plastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/Kp_rate </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1AssociativeKinematicPlasticHardening.html">link</a></p>
<h2><a class="anchor" id="associativeplasticflow"></a>
AssociativePlasticFlow</h2>
<p>Map the flow rate (i.e., the consistency parameter in the KKT conditions) to the rate of internal variables. This object calculates the rate of plastic strain following associative flow rule, i.e. \( \dot{\boldsymbol{\varepsilon}}_p = - \dot{\gamma} \frac{\partial f}{\partial \boldsymbol{M}} \), where \( \dot{\boldsymbol{\varepsilon}}_p \) is the plastic strain, \( \dot{\gamma} \) is the flow rate, \( f \) is the yield function, and \( \boldsymbol{M} \) is the Mandel stress. </p><details >
<summary >
<code>flow_direction</code> Flow direction which can be calculated using Normality</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/NM </li>
</ul>
</details>
<details >
<summary >
<code>flow_rate</code> Flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>plastic_strain_rate</code> Rate of plastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/Ep_rate </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1AssociativePlasticFlow.html">link</a></p>
<h2><a class="anchor" id="chabocheplastichardening"></a>
ChabochePlasticHardening</h2>
<p>Map the flow rate (i.e., the consistency parameter in the KKT conditions) to the rate of internal variables. This object defines the non-associative Chaboche kinematic hardening. In the Chaboche model, back stress is directly treated as an internal variable. Rate of back stress is given as \( \dot{\boldsymbol{X}} = \left( \frac{2}{3} C \frac{\partial f}{\partial \boldsymbol{M}} - g \boldsymbol{X} \right) \dot{\gamma} - A \lVert \boldsymbol{X} \rVert^{a - 1} \boldsymbol{X} \), including kinematic hardening, dynamic recovery, and static recovery. \( \frac{\partial f}{\partial \boldsymbol{M}} \) is the flow direction, \( \dot{\gamma} \) is the flow rate, and \( C \), \( g \), \( A \), and \( a \) are material parameters. </p><details >
<summary >
<code>A</code> Static recovery prefactor</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>C</code> Kinematic hardening coefficient</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>a</code> Static recovery exponent</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>back_stress</code> Back stress</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/X </li>
</ul>
</details>
<details >
<summary >
<code>flow_direction</code> Flow direction</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/NM </li>
</ul>
</details>
<details >
<summary >
<code>flow_rate</code> Flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>g</code> Dynamic recovery coefficient</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ChabochePlasticHardening.html">link</a></p>
<h2><a class="anchor" id="composedmodel"></a>
ComposedModel</h2>
<p>Compose multiple models together to form a single model. The composed model can then be treated as a new model and composed with others. The <a class="el" href="system-models.html#model-composition">system documentation</a> provides in-depth explanation on how the models are composed together. </p><details >
<summary >
<code>additional_outputs</code> Extra output variables to be extracted from the composed model in addition to the ones identified through dependency resolution.</summary>
<p></p>
<ul>
<li><u>Type</u>: vector&lt;VariableName&gt; </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling</code> Whether to perform automatic scaling. See neml2::NonlinearSystem::init_scaling for implementation details.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_miter</code> Maximum number of automatic scaling iterations. No error is produced upon reaching the maximum number of scaling iterations, and the scaling matrices obtained at the last iteration are used to scale the nonlinear system.</summary>
<p></p>
<ul>
<li><u>Type</u>: unsigned int</li>
<li><u>Default</u>: 20 </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_tol</code> Tolerance used in iteratively updating the scaling matrices.</summary>
<p></p>
<ul>
<li><u>Type</u>: double</li>
<li><u>Default</u>: 0.01 </li>
</ul>
</details>
<details >
<summary >
<code>models</code> Models being composed together</summary>
<p></p>
<ul>
<li><u>Type</u>: vector&lt;string&gt; </li>
</ul>
</details>
<details >
<summary >
<code>priority</code> Priorities of models in decreasing order. A model with higher priority will be evaluated first. This is useful for breaking cyclic dependency.</summary>
<p></p>
<ul>
<li><u>Type</u>: vector&lt;string&gt; </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ComposedModel.html">link</a></p>
<h2><a class="anchor" id="copymillerindex"></a>
CopyMillerIndex</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyquaternion"></a>
CopyQuaternion</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyr2"></a>
CopyR2</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyr3"></a>
CopyR3</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyr4"></a>
CopyR4</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyr5"></a>
CopyR5</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyrot"></a>
CopyRot</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copysffr4"></a>
CopySFFR4</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copysfr3"></a>
CopySFR3</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copysr2"></a>
CopySR2</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyssfr5"></a>
CopySSFR5</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyssr4"></a>
CopySSR4</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyswr4"></a>
CopySWR4</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyscalar"></a>
CopyScalar</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copyvec"></a>
CopyVec</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copywr2"></a>
CopyWR2</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copywsr4"></a>
CopyWSR4</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="copywwr4"></a>
CopyWWR4</h2>
<p>Copy the value from one variable to another. </p><details >
<summary >
<code>from</code> Variable to copy value from</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variable to copy value to</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1CopyVariable.html">link</a></p>
<h2><a class="anchor" id="elasticstrain"></a>
ElasticStrain</h2>
<p>Calculate elastic strain given total and plastic strain (assuming additive decomposition), i.e. \( \boldsymbol{\varepsilon}_e = \boldsymbol{\varepsilon} - \boldsymbol{\varepsilon}_p \). </p><details >
<summary >
<code>elastic_strain</code> Elastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/Ee </li>
</ul>
</details>
<details >
<summary >
<code>plastic_strain</code> Plastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/Ep </li>
</ul>
</details>
<details >
<summary >
<code>rate_form</code> Whether the model defines the relationship in rate form</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>total_strain</code> Total strain</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: forces/E </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ElasticStrain.html">link</a></p>
<h2><a class="anchor" id="elasticstrainrate"></a>
ElasticStrainRate</h2>
<details >
<summary >
<code>deformation_rate</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: forces/deformation_rate </li>
</ul>
</details>
<details >
<summary >
<code>elastic_strain</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/elastic_strain </li>
</ul>
</details>
<details >
<summary >
<code>elastic_strain_rate</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/elastic_strain_rate </li>
</ul>
</details>
<details >
<summary >
<code>plastic_deformation_rate</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/plastic_deformation_rate </li>
</ul>
</details>
<details >
<summary >
<code>vorticity</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: forces/vorticity </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ElasticStrainRate.html">link</a></p>
<h2><a class="anchor" id="fixorientation"></a>
FixOrientation</h2>
<details >
<summary >
<code>input_orientation</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/orientation </li>
</ul>
</details>
<details >
<summary >
<code>output_orientation</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/orientation </li>
</ul>
</details>
<details >
<summary >
<code>threshold</code></summary>
<p></p>
<ul>
<li><u>Type</u>: double</li>
<li><u>Default</u>: 1 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1FixOrientation.html">link</a></p>
<h2><a class="anchor" id="gtnyieldfunction"></a>
GTNYieldFunction</h2>
<p>Gurson-Tvergaard-Needleman yield function for poroplasticity. The yield function is defined as \( f = \left( \frac{\bar{\sigma}}{\sigma_y + k} \right)^2 + 2 q_1 \phi \cosh \left( \frac{1}{2} q_2 \frac{3\sigma_h-\sigma_s}{\sigma_y + k} \right) - \left( q_3 \phi^2 + 1 \right) \), where \( \bar{\sigma} \) is the von Mises stress, \( \sigma_y \) is the yield stress, \( k \) is isotropic hardening, \( \phi \) is the porosity, \( \sigma_h \) is the hydrostatic stress, and \( \sigma_s \) is the void growth back stress (sintering stress). \( q_1 \), \( q_2 \), and \( q_3 \) are parameters controlling the yield mechanisms. </p><details >
<summary >
<code>flow_invariant</code> Effective stress driving plastic flow</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/se </li>
</ul>
</details>
<details >
<summary >
<code>isotropic_hardening</code> Isotropic hardening</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>poro_invariant</code> Effective stress driving porous flow</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/sp </li>
</ul>
</details>
<details >
<summary >
<code>q1</code> Parameter controlling the balance/competition between plastic flow and void evolution.</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>q2</code> Void evolution rate</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>q3</code> Pore pressure</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>void_fraction</code> Void fraction (porosity)</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/f </li>
</ul>
</details>
<details >
<summary >
<code>yield_function</code> Yield function</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/fp </li>
</ul>
</details>
<details >
<summary >
<code>yield_stress</code> Yield stress</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1GTNYieldFunction.html">link</a></p>
<h2><a class="anchor" id="gursoncavitation"></a>
GursonCavitation</h2>
<p>Local mass balance used in conjunction with the GTNYieldFunction, \( \dot{\phi} = (1-\phi) \dot{\varepsilon}_p \). </p><details >
<summary >
<code>plastic_strain_rate</code> Plastic strain rate</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/Ep_rate </li>
</ul>
</details>
<details >
<summary >
<code>void_fraction</code> Void fraction (porosity)</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/f </li>
</ul>
</details>
<details >
<summary >
<code>void_fraction_rate</code> Rate of void evolution</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/f_rate </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1GursonCavitation.html">link</a></p>
<h2><a class="anchor" id="implicitupdate"></a>
ImplicitUpdate</h2>
<p>Update an implicit model by solving the underlying implicit system of equations. </p><details >
<summary >
<code>implicit_model</code> The implicit model defining the implicit system of equations to be solved</summary>
<p></p>
<ul>
<li><u>Type</u>: string </li>
</ul>
</details>
<details >
<summary >
<code>solver</code> Solver used to solve the implicit system</summary>
<p></p>
<ul>
<li><u>Type</u>: string </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ImplicitUpdate.html">link</a></p>
<h2><a class="anchor" id="isotropicmandelstress"></a>
IsotropicMandelStress</h2>
<p>Map Cauchy stress to Mandel stress For isotropic material under small deformation, the Mandel stress and the Cauchy stress coincide. </p><details >
<summary >
<code>cauchy_stress</code> Cauchy stress</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/S </li>
</ul>
</details>
<details >
<summary >
<code>mandel_stress</code> Mandel stress</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/M </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1IsotropicMandelStress.html">link</a></p>
<h2><a class="anchor" id="linearisotropicelasticity"></a>
LinearIsotropicElasticity</h2>
<p>Relate elastic strain to stress for linear isotropic material. \( \boldsymbol{\sigma} = K \tr \boldsymbol{\varepsilon}_e + 2 G \text{dev} \boldsymbol{\varepsilon}_e \), where \( K \) and \( G \) are bulk and shear moduli, respectively. For convenience, this object only requests Young's modulus and Poisson's ratio, and handles the Lame parameter conversion behind the scenes. </p><details >
<summary >
<code>compliance</code> Whether the model defines the compliance relationship, i.e., mapping from stress to elastic strain. When set to false (default), the model maps elastic strain to stress.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>poisson_ratio</code> Poisson's ratio</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>rate_form</code> Whether the model defines the stress-strain relationship in rate form. When set to true, the model maps elastic strain <em>rate</em> to stress <em>rate</em>.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>strain</code> Elastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/Ee </li>
</ul>
</details>
<details >
<summary >
<code>stress</code> Stress</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/S </li>
</ul>
</details>
<details >
<summary >
<code>youngs_modulus</code> Young's modulus</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearIsotropicElasticity.html">link</a></p>
<h2><a class="anchor" id="linearisotropichardening"></a>
LinearIsotropicHardening</h2>
<p>Map equivalent plastic strain to isotropic hardening following a linear relationship, i.e., \( k = H \varepsilon_p \) where \( H \) is the hardening modulus. </p><details >
<summary >
<code>equivalent_plastic_strain</code> Equivalent plastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/ep </li>
</ul>
</details>
<details >
<summary >
<code>hardening_modulus</code> Hardening modulus</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>isotropic_hardening</code> Isotropic hardening</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/k </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearIsotropicHardening.html">link</a></p>
<h2><a class="anchor" id="linearkinematichardening"></a>
LinearKinematicHardening</h2>
<p>Map kinematic plastic strain to back stress following a linear relationship, i.e., \( \boldsymbol{X} = H \boldsymbol{K}_p \) where \( H \) is the hardening modulus. </p><details >
<summary >
<code>back_stress</code> Back stress</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/X </li>
</ul>
</details>
<details >
<summary >
<code>hardening_modulus</code> Hardening modulus</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>kinematic_plastic_strain</code> Kinematic plastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/Kp </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearKinematicHardening.html">link</a></p>
<h2><a class="anchor" id="linearsinglesliphardeningrule"></a>
LinearSingleSlipHardeningRule</h2>
<details >
<summary >
<code>hardening_slope</code></summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>slip_hardening</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/slip_hardening </li>
</ul>
</details>
<details >
<summary >
<code>slip_hardening_rate</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/slip_hardening_rate </li>
</ul>
</details>
<details >
<summary >
<code>sum_slip_rates</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/sum_slip_rates </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearSingleSlipHardeningRule.html">link</a></p>
<h2><a class="anchor" id="millerindexlinearinterpolation"></a>
MillerIndexLinearInterpolation</h2>
<p>Interpolate a MillerIndex as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> MillerIndex defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: MillerIndex </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="normality"></a>
Normality</h2>
<p>Store the first derivatives of a scalar-valued function in given variables, i.e. \( u_i = \dfrac{f(\boldsymbol{v})}{v_i} \). </p><details >
<summary >
<code>from</code> Function arguments to take derivatives w.r.t.</summary>
<p></p>
<ul>
<li><u>Type</u>: vector&lt;VariableName&gt; </li>
</ul>
</details>
<details >
<summary >
<code>function</code> Function to take derivative</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>model</code> The model which evaluates the scalar-valued function</summary>
<p></p>
<ul>
<li><u>Type</u>: string </li>
</ul>
</details>
<details >
<summary >
<code>to</code> Variables to store the first derivatives</summary>
<p></p>
<ul>
<li><u>Type</u>: vector&lt;VariableName&gt; </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1Normality.html">link</a></p>
<h2><a class="anchor" id="olevskysinteringstress"></a>
OlevskySinteringStress</h2>
<p>Define the Olevsky-Skorohod sintering stress to be used in conjunction with poroplasticity yield functions such as the GTNYieldFunction. The sintering stress is defined as \( \sigma_s = 3 \dfrac{\gamma}{r} \phi^2 \), where \( \gamma \) is the surface tension, \( r \) is the size of the particles/powders, and \( \phi \) is the void fraction. </p><details >
<summary >
<code>particle_radius</code> Particle radius</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>sintering_stress</code> Sintering stress</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/ss </li>
</ul>
</details>
<details >
<summary >
<code>surface_tension</code> Surface tension</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>void_fraction</code> Void fraction</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/f </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1OlevskySinteringStress.html">link</a></p>
<h2><a class="anchor" id="orientationrate"></a>
OrientationRate</h2>
<details >
<summary >
<code>elastic_strain</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/elastic_strain </li>
</ul>
</details>
<details >
<summary >
<code>orientation_rate</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/orientation_rate </li>
</ul>
</details>
<details >
<summary >
<code>plastic_deformation_rate</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/plastic_deformation_rate </li>
</ul>
</details>
<details >
<summary >
<code>plastic_vorticity</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/plastic_vorticity </li>
</ul>
</details>
<details >
<summary >
<code>vorticity</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: forces/vorticity </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1OrientationRate.html">link</a></p>
<h2><a class="anchor" id="overstress"></a>
OverStress</h2>
<p>Calculate the over stress \( \boldsymbol{O} = \boldsymbol{M} - \boldsymbol{X} \), where \( \boldsymbol{M} \) is the Mandel stress and \( \boldsymbol{X} \) is the back stress. </p><details >
<summary >
<code>back_stress</code> Back stress</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/X </li>
</ul>
</details>
<details >
<summary >
<code>mandel_stress</code> Mandel stress</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/M </li>
</ul>
</details>
<details >
<summary >
<code>over_stress</code> Over stress</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/O </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1OverStress.html">link</a></p>
<h2><a class="anchor" id="perzynaplasticflowrate"></a>
PerzynaPlasticFlowRate</h2>
<p>Perzyna's viscous approximation of the consistent yield envelope (with a power law), i.e. \( \dot{\gamma} = \left( \frac{\left&lt; f \right&gt;}{\eta} \right)^n \), where \( f \) is the yield function, \( \eta \) is the reference stress, and \( n \) is the power-law exponent. </p><details >
<summary >
<code>exponent</code> Power-law exponent</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>flow_rate</code> Flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>reference_stress</code> Reference stress</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>yield_function</code> Yield function</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/fp </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1PerzynaPlasticFlowRate.html">link</a></p>
<h2><a class="anchor" id="plasticdeformationrate"></a>
PlasticDeformationRate</h2>
<details >
<summary >
<code>crystal_geometry_name</code></summary>
<p></p>
<ul>
<li><u>Type</u>: string</li>
<li><u>Default</u>: crystal_geometry </li>
</ul>
</details>
<details >
<summary >
<code>orientation</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/orientation_matrix </li>
</ul>
</details>
<details >
<summary >
<code>plastic_deformation_rate</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/plastic_deformation_rate </li>
</ul>
</details>
<details >
<summary >
<code>slip_rates</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/slip_rates </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1PlasticDeformationRate.html">link</a></p>
<h2><a class="anchor" id="plasticvorticity"></a>
PlasticVorticity</h2>
<details >
<summary >
<code>crystal_geometry_name</code></summary>
<p></p>
<ul>
<li><u>Type</u>: string</li>
<li><u>Default</u>: crystal_geometry </li>
</ul>
</details>
<details >
<summary >
<code>orientation</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/orientation_matrix </li>
</ul>
</details>
<details >
<summary >
<code>plastic_vorticity</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/plastic_vorticity </li>
</ul>
</details>
<details >
<summary >
<code>slip_rates</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/slip_rates </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1PlasticVorticity.html">link</a></p>
<h2><a class="anchor" id="powerlawsliprule"></a>
PowerLawSlipRule</h2>
<details >
<summary >
<code>crystal_geometry_name</code></summary>
<p></p>
<ul>
<li><u>Type</u>: string</li>
<li><u>Default</u>: crystal_geometry </li>
</ul>
</details>
<details >
<summary >
<code>gamma0</code></summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>n</code></summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>resolved_shears</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/resolved_shears </li>
</ul>
</details>
<details >
<summary >
<code>slip_rates</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/slip_rates </li>
</ul>
</details>
<details >
<summary >
<code>slip_strengths</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/slip_strengths </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1PowerLawSlipRule.html">link</a></p>
<h2><a class="anchor" id="quaternionlinearinterpolation"></a>
QuaternionLinearInterpolation</h2>
<p>Interpolate a Quaternion as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> Quaternion defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Quaternion </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="r2linearinterpolation"></a>
R2LinearInterpolation</h2>
<p>Interpolate a R2 as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> R2 defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: R2 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="r3linearinterpolation"></a>
R3LinearInterpolation</h2>
<p>Interpolate a R3 as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> R3 defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: R3 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="r4linearinterpolation"></a>
R4LinearInterpolation</h2>
<p>Interpolate a R4 as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> R4 defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: R4 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="r5linearinterpolation"></a>
R5LinearInterpolation</h2>
<p>Interpolate a R5 as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> R5 defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: R5 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="rateindependentplasticflowconstraint"></a>
RateIndependentPlasticFlowConstraint</h2>
<p>Solve the consistent plasticity yield envelope by solving the equivalent complementarity condition </p><p class="formulaDsp">
\[ r = \begin{cases} \dot{\gamma}, &amp; f &lt; 0 \\ f, &amp; f \geq 0. \end{cases} \]
</p>
 <details >
<summary >
<code>flow_rate</code> Flow rate</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/gamma_rate </li>
</ul>
</details>
<details >
<summary >
<code>yield_function</code> Yield function</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/fp </li>
</ul>
</details>
<details >
<summary >
<code>yielding_tolerance</code> Tolerance for determining whether the current material state is inside or outside the yield envelope</summary>
<p></p>
<ul>
<li><u>Type</u>: double</li>
<li><u>Default</u>: 1e-08 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1RateIndependentPlasticFlowConstraint.html">link</a></p>
<h2><a class="anchor" id="resolvedshear"></a>
ResolvedShear</h2>
<details >
<summary >
<code>crystal_geometry_name</code></summary>
<p></p>
<ul>
<li><u>Type</u>: string</li>
<li><u>Default</u>: crystal_geometry </li>
</ul>
</details>
<details >
<summary >
<code>orientation</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/orientation_matrix </li>
</ul>
</details>
<details >
<summary >
<code>resolved_shears</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/resolved_shears </li>
</ul>
</details>
<details >
<summary >
<code>stress</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/cauchy_stress </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ResolvedShear.html">link</a></p>
<h2><a class="anchor" id="rotlinearinterpolation"></a>
RotLinearInterpolation</h2>
<p>Interpolate a Rot as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> Rot defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Rot </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="rotationmatrix"></a>
RotationMatrix</h2>
<p>Convert a Rot (rotation represented in Rodrigues format) to R2 (a full rotation matrix). </p><details >
<summary >
<code>from</code> Rot to convert</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>to</code> R2 to store the resulting rotation matrix</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1RotationMatrix.html">link</a></p>
<h2><a class="anchor" id="sffr4linearinterpolation"></a>
SFFR4LinearInterpolation</h2>
<p>Interpolate a SFFR4 as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> SFFR4 defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: SFFR4 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="sfr3linearinterpolation"></a>
SFR3LinearInterpolation</h2>
<p>Interpolate a SFR3 as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> SFR3 defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: SFR3 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="sr2backwardeulertimeintegration"></a>
SR2BackwardEulerTimeIntegration</h2>
<p>Define the backward Euler time integration residual \( r = s - s_n - (t - t_n) \dot{s} \), where \(s\) is the variable being integrated, \(\dot{s}\) is the variable rate, and \(t\) is time. Subscripts \(n\) denote quantities from the previous time step. </p><details >
<summary >
<code>automatic_scaling</code> Whether to perform automatic scaling. See neml2::NonlinearSystem::init_scaling for implementation details.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_miter</code> Maximum number of automatic scaling iterations. No error is produced upon reaching the maximum number of scaling iterations, and the scaling matrices obtained at the last iteration are used to scale the nonlinear system.</summary>
<p></p>
<ul>
<li><u>Type</u>: unsigned int</li>
<li><u>Default</u>: 20 </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_tol</code> Tolerance used in iteratively updating the scaling matrices.</summary>
<p></p>
<ul>
<li><u>Type</u>: double</li>
<li><u>Default</u>: 0.01 </li>
</ul>
</details>
<details >
<summary >
<code>time</code> Time</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>variable_rate</code> Variable rate</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1BackwardEulerTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="sr2forcerate"></a>
SR2ForceRate</h2>
<p>Calculate the first order discrete time derivative of a force variable as \( \dot{f} = \frac{f-f_n}{t-t_n} \), where \( f \) is the force variable, and \( t \) is time. </p><details >
<summary >
<code>force</code> The force variable to take time derivative with</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>time</code> Time</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: t </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ForceRate.html">link</a></p>
<h2><a class="anchor" id="sr2forwardeulertimeintegration"></a>
SR2ForwardEulerTimeIntegration</h2>
<p>Perform forward Euler time integration defined as \( s = s_n + (t - t_n) \dot{s} \), where \(s\) is the variable being integrated, \(\dot{s}\) is the variable rate, and \(t\) is time. Subscripts \(n\) denote quantities from the previous time step. </p><details >
<summary >
<code>time</code> Time</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ForwardEulerTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="sr2invariant"></a>
SR2Invariant</h2>
<p>Calculate the invariant of a symmetric second order tensor (of type SR2). </p><details >
<summary >
<code>invariant</code> Invariant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>invariant_type</code> Type of invariant. Options are I1, I2, and VONMISES.</summary>
<p></p>
<ul>
<li><u>Type</u>: string </li>
</ul>
</details>
<details >
<summary >
<code>tensor</code> SR2 which is used to calculate the invariant of</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1SR2Invariant.html">link</a></p>
<h2><a class="anchor" id="sr2linearinterpolation"></a>
SR2LinearInterpolation</h2>
<p>Interpolate a SR2 as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> SR2 defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: SR2 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="sr2staterate"></a>
SR2StateRate</h2>
<p>Calculate the first order discrete time derivative of a state variable as \( \dot{s} = \frac{s-s_n}{t-t_n} \), where \( s \) is the state variable, and \( t \) is time. </p><details >
<summary >
<code>state</code> The state variable to take time derivative with</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>time</code> Time</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: t </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1StateRate.html">link</a></p>
<h2><a class="anchor" id="sr2summodel"></a>
SR2SumModel</h2>
<p>Calculate linear combination of multiple SR2 tensors as \( u = c_i v_i \) (Einstein summation assumed), where \( c_i \) are the coefficients, and \( v_i \) are the variables to be summed. </p><details >
<summary >
<code>coefficients</code> Weights associated with each variable</summary>
<p></p>
<ul>
<li><u>Type</u>: vector&lt;Scalar&gt; </li>
</ul>
</details>
<details >
<summary >
<code>from_var</code> SR2 tensors to be summed</summary>
<p></p>
<ul>
<li><u>Type</u>: vector&lt;VariableName&gt; </li>
</ul>
</details>
<details >
<summary >
<code>to_var</code> The sum</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1SumModel.html">link</a></p>
<h2><a class="anchor" id="ssfr5linearinterpolation"></a>
SSFR5LinearInterpolation</h2>
<p>Interpolate a SSFR5 as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> SSFR5 defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: SSFR5 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="ssr4linearinterpolation"></a>
SSR4LinearInterpolation</h2>
<p>Interpolate a SSR4 as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> SSR4 defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: SSR4 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="swr4linearinterpolation"></a>
SWR4LinearInterpolation</h2>
<p>Interpolate a SWR4 as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> SWR4 defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: SWR4 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="scalarbackwardeulertimeintegration"></a>
ScalarBackwardEulerTimeIntegration</h2>
<p>Define the backward Euler time integration residual \( r = s - s_n - (t - t_n) \dot{s} \), where \(s\) is the variable being integrated, \(\dot{s}\) is the variable rate, and \(t\) is time. Subscripts \(n\) denote quantities from the previous time step. </p><details >
<summary >
<code>automatic_scaling</code> Whether to perform automatic scaling. See neml2::NonlinearSystem::init_scaling for implementation details.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_miter</code> Maximum number of automatic scaling iterations. No error is produced upon reaching the maximum number of scaling iterations, and the scaling matrices obtained at the last iteration are used to scale the nonlinear system.</summary>
<p></p>
<ul>
<li><u>Type</u>: unsigned int</li>
<li><u>Default</u>: 20 </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_tol</code> Tolerance used in iteratively updating the scaling matrices.</summary>
<p></p>
<ul>
<li><u>Type</u>: double</li>
<li><u>Default</u>: 0.01 </li>
</ul>
</details>
<details >
<summary >
<code>time</code> Time</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>variable_rate</code> Variable rate</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1BackwardEulerTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="scalarforcerate"></a>
ScalarForceRate</h2>
<p>Calculate the first order discrete time derivative of a force variable as \( \dot{f} = \frac{f-f_n}{t-t_n} \), where \( f \) is the force variable, and \( t \) is time. </p><details >
<summary >
<code>force</code> The force variable to take time derivative with</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>time</code> Time</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: t </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ForceRate.html">link</a></p>
<h2><a class="anchor" id="scalarforwardeulertimeintegration"></a>
ScalarForwardEulerTimeIntegration</h2>
<p>Perform forward Euler time integration defined as \( s = s_n + (t - t_n) \dot{s} \), where \(s\) is the variable being integrated, \(\dot{s}\) is the variable rate, and \(t\) is time. Subscripts \(n\) denote quantities from the previous time step. </p><details >
<summary >
<code>time</code> Time</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ForwardEulerTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="scalarlinearinterpolation"></a>
ScalarLinearInterpolation</h2>
<p>Interpolate a Scalar as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> Scalar defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="scalarstaterate"></a>
ScalarStateRate</h2>
<p>Calculate the first order discrete time derivative of a state variable as \( \dot{s} = \frac{s-s_n}{t-t_n} \), where \( s \) is the state variable, and \( t \) is time. </p><details >
<summary >
<code>state</code> The state variable to take time derivative with</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>time</code> Time</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: t </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1StateRate.html">link</a></p>
<h2><a class="anchor" id="scalarsummodel"></a>
ScalarSumModel</h2>
<p>Calculate linear combination of multiple Scalar tensors as \( u = c_i v_i \) (Einstein summation assumed), where \( c_i \) are the coefficients, and \( v_i \) are the variables to be summed. </p><details >
<summary >
<code>coefficients</code> Weights associated with each variable</summary>
<p></p>
<ul>
<li><u>Type</u>: vector&lt;Scalar&gt; </li>
</ul>
</details>
<details >
<summary >
<code>from_var</code> Scalar tensors to be summed</summary>
<p></p>
<ul>
<li><u>Type</u>: vector&lt;VariableName&gt; </li>
</ul>
</details>
<details >
<summary >
<code>to_var</code> The sum</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1SumModel.html">link</a></p>
<h2><a class="anchor" id="singleslipstrengthmap"></a>
SingleSlipStrengthMap</h2>
<details >
<summary >
<code>constant_strength</code></summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>crystal_geometry_name</code></summary>
<p></p>
<ul>
<li><u>Type</u>: string</li>
<li><u>Default</u>: crystal_geometry </li>
</ul>
</details>
<details >
<summary >
<code>slip_hardening</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/slip_hardening </li>
</ul>
</details>
<details >
<summary >
<code>slip_strengths</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/slip_strengths </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1SingleSlipStrengthMap.html">link</a></p>
<h2><a class="anchor" id="sumsliprates"></a>
SumSlipRates</h2>
<details >
<summary >
<code>crystal_geometry_name</code></summary>
<p></p>
<ul>
<li><u>Type</u>: string</li>
<li><u>Default</u>: crystal_geometry </li>
</ul>
</details>
<details >
<summary >
<code>slip_rates</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/slip_rates </li>
</ul>
</details>
<details >
<summary >
<code>sum_slip_rates</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/sum_slip_rates </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1SumSlipRates.html">link</a></p>
<h2><a class="anchor" id="thermaleigenstrain"></a>
ThermalEigenstrain</h2>
<p>Define the (cummulative, as opposed to instantaneous) linear isotropic thermal eigenstrain, i.e. \( \boldsymbol{\varepsilon}_T = \alpha (T - T_0) \boldsymbol{I} \), where \( \alpha \) is the coefficient of thermal expansion (CTE), \( T \) is the temperature, and \( T_0 \) is the reference (stress-free) temperature. </p><details >
<summary >
<code>CTE</code> Coefficient of thermal expansion</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>eigenstrain</code> Eigenstrain</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: forces/Eg </li>
</ul>
</details>
<details >
<summary >
<code>reference_temperature</code> Reference (stress-free) temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>temperature</code> Temperature</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: forces/T </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1ThermalEigenstrain.html">link</a></p>
<h2><a class="anchor" id="totalstrain"></a>
TotalStrain</h2>
<p>Calculate the total strain by summing the elastic and plastic strain. </p><details >
<summary >
<code>elastic_strain</code> Elastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/Ee </li>
</ul>
</details>
<details >
<summary >
<code>plastic_strain</code> Plastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/Ep </li>
</ul>
</details>
<details >
<summary >
<code>rate_form</code> Whether to define the relationship in rate form</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>total_strain</code> Total strain</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/E </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1TotalStrain.html">link</a></p>
<h2><a class="anchor" id="vecbackwardeulertimeintegration"></a>
VecBackwardEulerTimeIntegration</h2>
<p>Define the backward Euler time integration residual \( r = s - s_n - (t - t_n) \dot{s} \), where \(s\) is the variable being integrated, \(\dot{s}\) is the variable rate, and \(t\) is time. Subscripts \(n\) denote quantities from the previous time step. </p><details >
<summary >
<code>automatic_scaling</code> Whether to perform automatic scaling. See neml2::NonlinearSystem::init_scaling for implementation details.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_miter</code> Maximum number of automatic scaling iterations. No error is produced upon reaching the maximum number of scaling iterations, and the scaling matrices obtained at the last iteration are used to scale the nonlinear system.</summary>
<p></p>
<ul>
<li><u>Type</u>: unsigned int</li>
<li><u>Default</u>: 20 </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_tol</code> Tolerance used in iteratively updating the scaling matrices.</summary>
<p></p>
<ul>
<li><u>Type</u>: double</li>
<li><u>Default</u>: 0.01 </li>
</ul>
</details>
<details >
<summary >
<code>time</code> Time</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>variable_rate</code> Variable rate</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1BackwardEulerTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="veclinearinterpolation"></a>
VecLinearInterpolation</h2>
<p>Interpolate a Vec as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> Vec defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Vec </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="voceisotropichardening"></a>
VoceIsotropicHardening</h2>
<p>Voce isotropic hardening model, \( h = R \left[ 1 - \exp(-d \varepsilon_p) \right] \), where \( R \) is the isotropic hardening upon saturation, and \( d \) is the hardening rate. </p><details >
<summary >
<code>equivalent_plastic_strain</code> Equivalent plastic strain</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/ep </li>
</ul>
</details>
<details >
<summary >
<code>isotropic_hardening</code> Isotropic hardening</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/k </li>
</ul>
</details>
<details >
<summary >
<code>saturated_hardening</code> Saturated isotropic hardening</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>saturation_rate</code> Hardening saturation rate</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1VoceIsotropicHardening.html">link</a></p>
<h2><a class="anchor" id="vocesinglesliphardeningrule"></a>
VoceSingleSlipHardeningRule</h2>
<details >
<summary >
<code>initial_slope</code></summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>saturated_hardening</code></summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>slip_hardening</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/slip_hardening </li>
</ul>
</details>
<details >
<summary >
<code>slip_hardening_rate</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/slip_hardening_rate </li>
</ul>
</details>
<details >
<summary >
<code>sum_slip_rates</code></summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/sum_slip_rates </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1VoceSingleSlipHardeningRule.html">link</a></p>
<h2><a class="anchor" id="wr2explicitexponentialtimeintegration"></a>
WR2ExplicitExponentialTimeIntegration</h2>
<p>Perform explicit discrete exponential time integration of a rotation. The update can be written as \( s = \exp\left[ (t-t_n)\dot{s}\right] \circ s_n \), where \( \circ \) denotes the rotation operator. </p><details >
<summary >
<code>time</code> Time</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1WR2ExplicitExponentialTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="wr2implicitexponentialtimeintegration"></a>
WR2ImplicitExponentialTimeIntegration</h2>
<p>Define the implicit discrete exponential time integration residual of a rotation variable. The residual can be written as \( r = s - \exp\left[ (t-t_n)\dot{s}\right] \circ s_n \), where \( \circ \) denotes the rotation operator. </p><details >
<summary >
<code>automatic_scaling</code> Whether to perform automatic scaling. See neml2::NonlinearSystem::init_scaling for implementation details.</summary>
<p></p>
<ul>
<li><u>Type</u>: bool</li>
<li><u>Default</u>: false </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_miter</code> Maximum number of automatic scaling iterations. No error is produced upon reaching the maximum number of scaling iterations, and the scaling matrices obtained at the last iteration are used to scale the nonlinear system.</summary>
<p></p>
<ul>
<li><u>Type</u>: unsigned int</li>
<li><u>Default</u>: 20 </li>
</ul>
</details>
<details >
<summary >
<code>automatic_scaling_tol</code> Tolerance used in iteratively updating the scaling matrices.</summary>
<p></p>
<ul>
<li><u>Type</u>: double</li>
<li><u>Default</u>: 0.01 </li>
</ul>
</details>
<details >
<summary >
<code>time</code> Time</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: t </li>
</ul>
</details>
<details >
<summary >
<code>variable</code> Variable being integrated</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1WR2ImplicitExponentialTimeIntegration.html">link</a></p>
<h2><a class="anchor" id="wr2linearinterpolation"></a>
WR2LinearInterpolation</h2>
<p>Interpolate a WR2 as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> WR2 defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: WR2 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="wsr4linearinterpolation"></a>
WSR4LinearInterpolation</h2>
<p>Interpolate a WSR4 as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> WSR4 defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: WSR4 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="wwr4linearinterpolation"></a>
WWR4LinearInterpolation</h2>
<p>Interpolate a WWR4 as a function of the given argument. See <a class="el" href="classneml2_1_1Interpolation.html" title="The base class for interpolated nonlinear parameter.">neml2::Interpolation</a> for rules on shapes of the interpolant and the argument. This object performs a <em>linear interpolation</em>. </p><details >
<summary >
<code>abscissa</code> Scalar defining the abscissa values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<details >
<summary >
<code>argument</code> Argument used to query the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>ordinate</code> WWR4 defining the ordinate values of the interpolant</summary>
<p></p>
<ul>
<li><u>Type</u>: WWR4 </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1LinearInterpolation.html">link</a></p>
<h2><a class="anchor" id="yieldfunction"></a>
YieldFunction</h2>
<p>Classical macroscale plasticity yield function, \( f = \bar{\sigma} - \sigma_y - h \), where \( \bar{\sigma} \) is the effective stress, \( \sigma_y \) is the yield stress, and \( h \) is the isotropic hardening. </p><details >
<summary >
<code>effective_stress</code> Effective stress</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/s </li>
</ul>
</details>
<details >
<summary >
<code>isotropic_hardening</code> Isotropic hardening</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName </li>
</ul>
</details>
<details >
<summary >
<code>yield_function</code> Yield function</summary>
<p></p>
<ul>
<li><u>Type</u>: VariableName</li>
<li><u>Default</u>: state/internal/fp </li>
</ul>
</details>
<details >
<summary >
<code>yield_stress</code> Yield stress</summary>
<p></p>
<ul>
<li><u>Type</u>: Scalar </li>
</ul>
</details>
<p>Detailed documentation <a class="el" href="classneml2_1_1YieldFunction.html">link</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
